<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SNEKED - Predator Mode</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; user-select: none; touch-action: none; }
        #game-wrapper { display: flex; flex-direction: column; height: 100vh; width: 100vw; display: none; }
        .screen { flex: 1; position: relative; border-bottom: 4px solid #333; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        
        #menu { 
            position: absolute; width: 100%; height: 100%; background: #000; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }

        #powerup-screen { 
            position: absolute; width: 100%; height: 100%; background: #000; 
            display: none; flex-direction: column; z-index: 1000;
        }

        .selection-area {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; box-sizing: border-box; padding: 10px;
        }
        
        .powerup-divider {
    height: 4px;
    background: #333;
    width: 100%;
}
        .p1-multi-style { transform: rotate(180deg); }

        @keyframes pulseMagenta {
            0% { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; }
            50% { text-shadow: 0 0 25px #ff00ff, 0 0 50px #ff00ff, 0 0 70px #ff00ff; }
            100% { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; }
        }
        .title { font-size: 5rem; color: #ff00ff; margin-bottom: 40px; animation: pulseMagenta 1.5s infinite ease-in-out; font-weight: 900; }
        .subtitle { color: #fff; font-size: 1.5rem; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }

        .menu-btn, .power-btn {
            margin: 5px; padding: 12px 0; background: transparent; 
            color: #00f2ff; border: 3px solid #00f2ff; font-size: 1.1rem; 
            font-weight: bold; border-radius: 10px; cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.2); transition: 0.2s;
            width: 280px; text-align: center;
        }
        .p2-selection .power-btn { color: #ff00de; border-color: #ff00de; }
                /* Back Button Styling */
        .back-btn {
            position: absolute;
            z-index: 1100;
            padding: 8px 15px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
        }
                /* ---------- SINGLE PLAYER BACK BUTTON ---------- */
#powerup-screen[data-mode="1"] #p1-back {
    top: 20px;
    left: 20px;
    transform: rotate(0deg);
}

/* ---------- MULTIPLAYER BACK BUTTON (UNCHANGED) ---------- */
#powerup-screen[data-mode="2"] #p1-back {
    top: 231.5px;
    left: 316px;
    transform: rotate(180deg);
}

/* P2 top-left from THEIR perspective = top-right of screen */
#p2-back {
    top: 389px;
    right: 315.75px;
} 
        
        /* Ensure the gray line is visible in multiplayer */
        #powerup-screen[data-mode="2"] .powerup-divider { display: block; }

                        /* Base styling for the color columns */
        .color-row {
            display: flex;
            gap: 10px;
            position: absolute;
            flex-direction: column;
            justify-content: center;
            z-index: 10;
        }

        /* MANUAL ADJUSTMENT FOR PLAYER 1 (Left Side) */
        #p1-color-row {
            top: 54.75px;   /* DECREASE this number to move it DOWN | INCREASE to move it UP */
            right: 25px;  /* INCREASE to move it LEFT | DECREASE to move it RIGHT */
        }

        /* MANUAL ADJUSTMENT FOR PLAYER 2 (Right Side) */
        #p2-color-row {
            top: 386.25px;   /* INCREASE this number to move it DOWN | DECREASE to move it UP */
            right: 25px;  /* INCREASE to move it LEFT | DECREASE to move it RIGHT */
        }

        /* Keep horizontal for single player */
        #powerup-screen[data-mode="1"] .color-row {
            position: static;
            flex-direction: row;
            margin-top: 15px;
            transform: none;
        }
        /* Keep horizontal for single player */
        #powerup-screen[data-mode="1"] .color-row {
            position: static;
            flex-direction: row;
            margin-top: 15px;
        }
        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-box.selected {
            border-color: #fff;
            transform: scale(1.2);
            box-shadow: 0 0 10px #fff;
        }
        /* Difficulty Buttons - Horizontal (Single Player) */
.difficulty-row-horizontal {
    display: none; /* Hidden by default, shown in single player */
    flex-direction: row;
    gap: 8px;
    margin-top: 15px;
    justify-content: center;
}

.difficulty-btn {
    padding: 8px 15px;
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    border: 1px solid #555;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 0.8rem;
    transition: all 0.2s;
}

.difficulty-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.difficulty-btn.selected {
    background: rgba(255, 255, 255, 0.3);
    border-color: #fff;
    color: #fff;
}

/* Difficulty Buttons - Vertical (Multiplayer) */
.difficulty-row-vertical {
    display: none; /* Hidden by default, shown in multiplayer */
    position: absolute;
    left: 25px;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
}

/* P1 vertical positioning */
#p1-difficulty-vertical {
    top: 105px;  /* MANUAL ADJUSTMENT: Aligned with P1's color buttons */
    transform: translateY(0) rotate(180deg);  /* Removed centering, using absolute positioning */
}

/* NEW ADDITION: Flip the letters inside P1's buttons so they are readable */
#p1-difficulty-vertical .difficulty-btn-vertical {
    transform: rotate(180deg);
}

/* P2 vertical positioning */
#p2-difficulty-vertical {
    top: 435.5px;  /* MANUAL ADJUSTMENT: Aligned with P2's color buttons */
    transform: translateY(0);  /* Removed centering, using absolute positioning */
}

.difficulty-btn-vertical {
    padding: 6px 9px;  /* 25% smaller: was 8px 12px */
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    border: 1px solid #555;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 0.525rem;  /* 25% smaller: was 0.7rem */
    writing-mode: vertical-rl;
    text-orientation: upright;
    letter-spacing: 2px;  /* CHANGED: More spacing between letters (was -2px) */
    transition: all 0.2s;
    width: 30px;  /* 25% smaller: was 40px */
    height: 60px;  /* 25% smaller: was 80px */
    display: flex;
    align-items: center;
    justify-content: center;
}

.difficulty-btn-vertical:hover {
    background: rgba(255, 255, 255, 0.2);
}

.difficulty-btn-vertical.selected {
    background: rgba(255, 255, 255, 0.3);
    border-color: #fff;
    color: #fff;
}

/* P2 buttons should also be white when selected */
#p2-difficulty-vertical .difficulty-btn-vertical.selected {
    background: rgba(255, 255, 255, 0.3);
    border-color: #fff;
    color: #fff;
}

/* Nightmare difficulty button styling */
.difficulty-btn.nightmare-btn {
    color: #ff0000;
    border-color: #ff0000;
    font-size: 1rem;
    width: 100%;
    margin-top: 10px;
    letter-spacing: 3px;
}

.difficulty-btn.nightmare-btn.selected {
    background: rgba(255, 0, 0, 0.3);
    border-color: #ff0000;
    color: #ff0000;
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
}

        .menu-btn:active, .power-btn:active { background: rgba(255, 255, 255, 0.1); transform: scale(0.95); }
        .power-btn.selected { background: #fff; color: #000; border-color: #fff; }
        
        #powerup-screen[data-mode="2"] .power-btn {
            margin: 3px; padding: 6px 0; font-size: 0.9rem; width: 220px;
        }

        .ui-container { position: absolute; pointer-events: none; z-index: 20; display: flex; flex-direction: column; align-items: center; width: 150px; }
        .ui { font-weight: bold; font-size: 1.1rem; color: white; opacity: 0.9; text-shadow: 2px 2px #000; margin-bottom: 10px; }
        
        .ability-btn {
            position: fixed;
            left: 25px;
            z-index: 30;
            pointer-events: auto; padding: 5px 12px; background: rgba(0, 0, 0, 0.6); 
            border: 2px solid #fff; color: #fff; font-weight: bold; 
            font-family: inherit; font-size: 0.75rem; cursor: pointer;
            display: none; border-radius: 4px; text-transform: uppercase;
            width: 80px; text-align: center; transition: filter 0.3s, opacity 0.3s;
        }

        .p1-ui-sp { top: 20px; right: 20px; } 
        .p1-ui-sp-btn { bottom: 225px; }
        .p1-ui-mp { bottom: 20px; left: 20px; transform: rotate(180deg); } 
        .p1-ui-mp-btn { top: 225px; left: auto; right: 20px; transform: rotate(180deg); } 

        .p2-ui-pos { top: 20px; right: 20px; }
        .p2-ui-mp-btn { bottom: 225px; left: 20px; }

        #p1-ui { color: #00f2ff; }
        #p2-ui { color: #ff00de; }

        .ability-btn.cooldown {
    filter: grayscale(1); opacity: 0.5; pointer-events: none; border-color: #555 !important; color: #555 !important;
}
.emp-style { border-color: #00f2ff; color: #00f2ff; }
.venom-style { border-color: #2bff00; color: #2bff00; }
.ghost-style { border-color: #ffffff; color: #ffffff; }
.gravity-style { border-color: #001f5f; color: #001f5f; }
.boost-style { border-color: #bc13fe; color: #bc13fe; }
.killshot-style { border-color: #ff0000; color: #ff0000; }

        .exit-btn { position: absolute; z-index: 50; padding: 8px 15px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #555; border-radius: 5px; cursor: pointer; font-family: inherit; }
        #p1-exit, #p2-exit { top: 20px; left: 20px; }
        #p1-exit.multi-exit { top: auto; left: auto; bottom: 20px; right: 20px; transform: rotate(180deg); }
        .leaderboard { position: absolute; background: rgba(0,0,0,0.6); padding: 5px; border-radius: 3px; font-size: 0.55rem; color: #aaa; z-index: 20; width: 90px; border: 1px solid #444; box-sizing: border-box; overflow: hidden; }
        #p1-board, #p2-board { bottom: 120px; left: 20px; text-align: left; }
        #p1-board.multi { top: 120px; right: 20px; bottom: auto; left: auto; text-align: right; }
        .p1-board-rotate { transform: rotate(180deg); }
        .lb-title { color: gold; font-size: 0.6rem; border-bottom: 1px solid #555; margin-bottom: 3px; font-weight: bold; text-transform: uppercase; }
        .lb-item { display: flex; justify-content: space-between; width: 100%; white-space: nowrap; margin-bottom: 1px; }
        .lb-name { overflow: hidden; text-overflow: ellipsis; max-width: 60px; }
        .lb-score { color: #fff; font-weight: bold; }
        .lb-leader { color: gold !important; text-shadow: 0 0 5px gold; }
        .menu-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; background: rgba(0,0,0,0.95); padding: 30px; display: none; text-align: center; border-radius: 15px; pointer-events: auto; }
.pause-menu { border: 2px solid #ff00ff; z-index: 150; }
.respawn-menu { border: 2px solid red; z-index: 100; }
        .respawn-btn { margin-top: 15px; padding: 12px 24px; background: red; color: white; border: none; font-weight: bold; border-radius: 5px; cursor: pointer; font-family: inherit; }
    </style>
</head>
<body oncontextmenu="return false;" style="-webkit-user-select: none; -webkit-touch-callout: none;">

<div id="menu">
    <div class="title">SNEKED</div>
    <button class="menu-btn" onclick="showPowerupSelect(1)">SINGLE PLAYER</button>
    <button class="menu-btn" onclick="withVibrate(() => showPowerupSelect(2))">MULTIPLAYER</button>
    <button class="menu-btn" onclick="showControls()">CONTROLS</button>
    <button class="menu-btn" onclick="showStats()">STATS</button>
</div>

<div id="powerup-screen">
        <button class="back-btn" id="p1-back" onclick="goToMenu()">BACK</button>
    <button class="back-btn" id="p2-back" onclick="goToMenu()" style="display:none;">BACK</button>
    <div class="selection-area p1-selection" id="p1-select-area">
    <div class="subtitle" id="p1-subtitle">P2: Power-Up & Color</div>
    <button class="power-btn" onclick="selectPower(1, 1)">EMP</button>
    <button class="power-btn" onclick="selectPower(1, 2)">VENOM</button>
    <button class="power-btn" onclick="selectPower(1, 3)">GHOST</button>
    <button class="power-btn" onclick="selectPower(1, 4)">GRAVITY WELL</button>
    <button class="power-btn" onclick="selectPower(1, 5)">SPEED BOOST</button>
    <button class="power-btn" onclick="selectPower(1, 6)">KILLSHOT</button>
                <div class="color-row" id="p1-color-row">
            <div class="color-box" style="background: #2bff00;" onclick="selectColor(1, '#2bff00')"></div>
            <div class="color-box" style="background: #00f2ff;" onclick="selectColor(1, '#00f2ff')"></div>
            <div class="color-box" style="background: #ff00de;" onclick="selectColor(1, '#ff00de')"></div>
            <div class="color-box" style="background: #bc13fe;" onclick="selectColor(1, '#bc13fe')"></div>
            <div class="color-box" style="background: #ff0000;" onclick="selectColor(1, '#ff0000')"></div>
            <div class="color-box" style="background: #ff8800;" onclick="selectColor(1, '#ff8800')"></div>
        </div>
            <!--             <!-- Difficulty buttons for Single Player (horizontal) -->
    <div class="difficulty-row-horizontal" id="p1-difficulty-row">
        <button class="difficulty-btn" onclick="selectDifficulty(1, 'easy')">EASY</button>
        <button class="difficulty-btn selected" onclick="selectDifficulty(1, 'normal')">NORMAL</button>
        <button class="difficulty-btn" onclick="selectDifficulty(1, 'hard')">HARD</button>
        <button class="difficulty-btn nightmare-btn" onclick="selectDifficulty(1, 'nightmare')">NIGHTMARE</button>
    </div>
    <!-- Difficulty buttons for Multiplayer (vertical, left side) -->
    <div class="difficulty-row-vertical" id="p1-difficulty-vertical">
        <button class="difficulty-btn-vertical" onclick="selectDifficulty(1, 'easy')">EASY</button>
        <button class="difficulty-btn-vertical selected" onclick="selectDifficulty(1, 'normal')">NORMAL</button>
        <button class="difficulty-btn-vertical" onclick="selectDifficulty(1, 'hard')">HARD</button>
    </div>
    </div>
    <div class="powerup-divider" id="menu-divider"></div>
    <div class="selection-area p2-selection" id="p2-select-area">
    <div class="subtitle">P1: Power-Up & Color</div>
    <button class="power-btn" onclick="selectPower(2, 1)">EMP</button>
    <button class="power-btn" onclick="selectPower(2, 2)">VENOM</button>
    <button class="power-btn" onclick="selectPower(2, 3)">GHOST</button>
    <button class="power-btn" onclick="selectPower(2, 4)">GRAVITY WELL</button>
    <button class="power-btn" onclick="selectPower(2, 5)">SPEED BOOST</button>
    <button class="power-btn" onclick="selectPower(2, 6)">KILLSHOT</button>
                <div class="color-row" id="p2-color-row">
            <div class="color-box" style="background: #2bff00;" onclick="selectColor(2, '#2bff00')"></div>
            <div class="color-box" style="background: #00f2ff;" onclick="selectColor(2, '#00f2ff')"></div>
            <div class="color-box" style="background: #ff00de;" onclick="selectColor(2, '#ff00de')"></div>
            <div class="color-box" style="background: #bc13fe;" onclick="selectColor(2, '#bc13fe')"></div>
            <div class="color-box" style="background: #ff0000;" onclick="selectColor(2, '#ff0000')"></div>
            <div class="color-box" style="background: #ff8800;" onclick="selectColor(2, '#ff8800')"></div>
        </div>
            <!-- Difficulty buttons for Multiplayer P2 (vertical, left side) -->
    <div class="difficulty-row-vertical" id="p2-difficulty-vertical">
        <button class="difficulty-btn-vertical" onclick="selectDifficulty(2, 'easy')">EASY</button>
        <button class="difficulty-btn-vertical selected" onclick="selectDifficulty(2, 'normal')">NORMAL</button>
        <button class="difficulty-btn-vertical" onclick="selectDifficulty(2, 'hard')">HARD</button>
    </div>
    </div>
</div>
<!-- CONTROLS SCREEN -->
<div id="controls-screen" style="display: none; position: absolute; width: 100%; height: 100%; background: #000; z-index: 1000; overflow: hidden;">
    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 5px 20px; box-sizing: border-box;">
        
        <div style="text-align: center; flex-shrink: 0; margin-top: 10px;">
            <div style="font-size: 2.75rem; color: #ff00ff; font-weight: 900; margin-bottom: 2px; line-height: 1;">CONTROLS</div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 8px;">
                <button class="back-btn" style="position: static;" onclick="backToMainMenu()">BACK</button>
                <button class="back-btn" style="position: static;" onclick="goToNextMenu()">NEXT</button>
            </div>
        </div>
        
        <div style="width: 90%; max-width: 400px; background: rgba(255, 255, 255, 0.05); border: 2px solid #333; border-radius: 10px; padding: 10px; text-align: center; flex-shrink: 0; margin-bottom: 10px;">
            <div style="color: #00f2ff; font-size: 0.75rem; line-height: 1.2; display: flex; flex-wrap: wrap; justify-content: center; gap: 4px;">
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
            </div>
        </div>
        
        <div style="position: relative; width: 96.25%; max-width: 400px; height: 240px; border: 2px solid #333; border-radius: 10px; overflow: hidden; flex-shrink: 0; margin-bottom: 10px;">
            <div style="width: 100%; height: 100%; background: #000; position: relative;">
                <svg style="position: absolute; width: 100%; height: 100%; opacity: 0.2;">
                    <rect width="100%" height="100%" fill="url(#grid)" />
                </svg>

                <div style="position: absolute; top: 10px; right: 15px; color: #00f2ff; font-weight: bold; font-size: 0.9rem; text-shadow: 2px 2px #000;">YOU: 284</div>
                
                <svg style="position: absolute; width: 100%; height: 100%; opacity: 0.5;">
                    <circle cx="20" cy="30" r="2" fill="hsl(120, 100%, 50%)"/>
                    <circle cx="50" cy="80" r="2" fill="hsl(200, 100%, 50%)"/>
                    <circle cx="80" cy="40" r="2" fill="hsl(300, 100%, 50%)"/>
                    <circle cx="120" cy="20" r="2" fill="hsl(60, 100%, 50%)"/>
                    <circle cx="160" cy="60" r="2" fill="hsl(10, 100%, 50%)"/>
                    <circle cx="200" cy="30" r="2" fill="hsl(180, 100%, 50%)"/>
                    <circle cx="240" cy="70" r="2" fill="hsl(280, 100%, 50%)"/>
                    <circle cx="280" cy="40" r="2" fill="hsl(90, 100%, 50%)"/>
                    <circle cx="320" cy="20" r="2" fill="hsl(40, 100%, 50%)"/>
                    <circle cx="360" cy="50" r="2" fill="hsl(330, 100%, 50%)"/>
                    <circle cx="40" cy="150" r="2" fill="hsl(220, 100%, 50%)"/>
                    <circle cx="90" cy="180" r="2" fill="hsl(150, 100%, 50%)"/>
                    <circle cx="130" cy="140" r="2" fill="hsl(350, 100%, 50%)"/>
                    <circle cx="180" cy="170" r="2" fill="hsl(50, 100%, 50%)"/>
                    <circle cx="230" cy="130" r="2" fill="hsl(260, 100%, 50%)"/>
                    <circle cx="280" cy="160" r="2" fill="hsl(190, 100%, 50%)"/>
                    <circle cx="330" cy="120" r="2" fill="hsl(100, 100%, 50%)"/>
                    <circle cx="370" cy="150" r="2" fill="hsl(310, 100%, 50%)"/>
                    <circle cx="60" cy="220" r="2" fill="hsl(140, 100%, 50%)"/>
                    <circle cx="150" cy="210" r="2" fill="hsl(20, 100%, 50%)"/>
                    <circle cx="250" cy="230" r="2" fill="hsl(240, 100%, 50%)"/>
                    <circle cx="340" cy="210" r="2" fill="hsl(80, 100%, 50%)"/>
                </svg>

                <svg style="position: absolute; width: 100%; height: 100%;">
                    <defs>
                        <radialGradient id="cyanAura">
                            <stop offset="0%" style="stop-color:rgba(0,242,255,0.4);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:rgba(0,242,255,0);stop-opacity:0" />
                        </radialGradient>
                        <radialGradient id="goldAura">
                            <stop offset="0%" style="stop-color:rgba(255,215,0,0.4);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:rgba(255,215,0,0);stop-opacity:0" />
                        </radialGradient>
                         <radialGradient id="whiteAura">
                            <stop offset="0%" style="stop-color:rgba(255,0,0,0.5);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:rgba(255,0,0,0);stop-opacity:0" />
                        </radialGradient>
                    </defs>

                    <circle cx="250" cy="110" r="40" fill="url(#cyanAura)"/> 
                    <path d="M 250 110 Q 230 130, 210 180" stroke="#ff00de" stroke-width="10" fill="none" stroke-linecap="round"/>
                </svg>

                <svg style="position: absolute; width: 100%; height: 100%;">
                    <circle cx="160" cy="120" r="80" fill="url(#goldAura)"/>
                    <path d="M 160 120 Q 150 145, 145 220" stroke="gold" stroke-width="14" fill="none" stroke-linecap="round"/>
                    <text x="160" y="100" font-size="34" text-anchor="middle" fill="gold">ðŸ‘‘</text>
                </svg>
                
                <svg style="position: absolute; width: 100%; height: 100%;">
    <g transform="translate(115, -80)">
        <circle cx="70" cy="120" r="40" fill="url(#whiteAura)"/>
        <path d="M 70 120 Q 90 150, 80 210"
              stroke="#ffffff"
              stroke-width="8"
              fill="none"
              stroke-linecap="round"/>
    </g>
</svg>
                
                <svg style="position: absolute; width: 100%; height: 100%;">
                    <circle cx="300" cy="100" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                    <circle cx="295" cy="115" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                    <circle cx="290" cy="130" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                    <circle cx="285" cy="145" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                    <circle cx="280" cy="160" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                    <circle cx="275" cy="175" r="5" fill="#fff" style="filter: drop-shadow(0 0 4px #fff);"/>
                </svg>
                
                <div style="position: absolute; bottom: 8px; left: 10px; display: flex; flex-direction: column; align-items: center; gap: 6px;">
                    <button style="padding: 3px; background: rgba(0, 0, 0, 0.6); border: 2px solid #00f2ff; color: #00f2ff; font-weight: bold; font-family: inherit; font-size: 0.5rem; border-radius: 4px; width: 80px; pointer-events: none;">POWER</button>

                    <div style="background: rgba(0,0,0,0.6); padding: 5px; border-radius: 3px; font-size: 0.45rem; color: #aaa; width: 90px; height: 75px; border: 1px solid #444; box-sizing: border-box;">
                        <div style="color: gold; font-size: 0.5rem; border-bottom: 1px solid #555; margin-bottom: 3px; font-weight: bold;">LEADERBOARD</div>
<div style="display: flex; justify-content: space-between; color: gold; font-weight: bold; margin-bottom: 1px;"><span>1.Apex</span><span>284</span></div>
<div style="display: flex; justify-content: space-between; margin-bottom: 1px;"><span>2.Xenon</span><span>142</span></div>
<div style="display: flex; justify-content: space-between; margin-bottom: 1px;"><span>3.Viper</span><span>98</span></div>
<div style="display: flex; justify-content: space-between; margin-bottom: 1px;"><span>4.Bolt</span><span>76</span></div>
<div style="display: flex; justify-content: space-between; margin-bottom: 1px;"><span>5.Neon</span><span>54</span></div>
                    </div>

                    <div style="width: 90px; height: 70px; background: rgba(17, 17, 17, 0.6); border: 1px solid #ff0000; border-radius: 3px; position: relative; overflow: hidden;">
                         <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 10px; left: 10px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 15px; left: 60px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 50px; left: 20px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 40px; left: 70px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 5px; left: 30px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 25px; left: 80px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 60px; left: 45px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 55px; left: 10px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 30px; left: 5px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 12px; left: 45px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 48px; left: 85px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 65px; left: 75px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 22px; left: 55px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 35px; left: 25px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 8px; left: 78px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 52px; left: 55px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 18px; left: 20px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 42px; left: 65px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 62px; left: 35px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 5px; left: 50px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 38px; left: 80px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 28px; left: 15px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 58px; left: 60px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 15px; left: 35px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 45px; left: 40px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 25px; left: 65px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 65px; left: 25px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 10px; left: 85px; border-radius: 50%;"></div>
                        <div style="position: absolute; width: 4px; height: 4px; background: #fff; top: 32px; left: 50px; border-radius: 50%;"></div>
                        
                        <div style="position: absolute; width: 4px; height: 4px; background: gold; top: 25px; left: 40px; border-radius: 50%;"></div> 
                        <div style="position: absolute; width: 4px; height: 4px; background: #ff00de; top: 35px; left: 35px; border-radius: 50%;"></div> 
                        <div style="position: absolute; width: 4px; height: 4px; background: #00f2ff; top: 45px; left: 55px; border-radius: 50%;"></div> 
                    </div>
                </div>
            </div>
        </div>
        
        <div style="width: 90%; max-width: 400px; background: rgba(255, 255, 255, 0.05); border: 2px solid #333; border-radius: 10px; padding: 10px; text-align: center; flex-shrink: 0; margin-bottom: 10px;">
            <div style="color: #00f2ff; font-size: 0.75rem; line-height: 1.2; display: flex; flex-wrap: wrap; justify-content: center; gap: 4px;">
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
                <span style="width: 100%;">???? ???? ???? ???? ???? ???? ???? ????</span>
            </div>
        </div>
    </div>
</div>

<div id="next-menu" style="display: none; position: absolute; width: 100%; height: 100%; background: #000; z-index: 1000; flex-direction: column; align-items: center; justify-content: center;">
    <button class="back-btn" style="top: 20px; left: 20px;" onclick="backToControls()">BACK</button>
    <div style="font-size: 3rem; color: #ff00ff; font-weight: 900;">PLACEHOLDER</div>
    <div style="color: #00f2ff; font-size: 1.2rem; margin-top: 20px;">This menu will be implemented later</div>
</div>

<!-- STATS SCREEN -->
<div id="stats-screen" style="display: none; position: absolute; width: 100%; height: 100%; background: #000; z-index: 1000; overflow: hidden;">
    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; box-sizing: border-box;">
        <button class="back-btn" style="position: absolute; top: 20px; left: 20px;" onclick="backToMainMenuFromStats()">BACK</button>
        
        <div style="font-size: 3rem; color: #ff00ff; font-weight: 900; margin-bottom: 30px;">STATS</div>
        
        <div style="width: 90%; max-width: 500px; background: rgba(255, 255, 255, 0.05); border: 2px solid #333; border-radius: 10px; padding: 20px; text-align: left;">
            <div style="color: #00f2ff; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: space-between;">
                <span>Highest Score:</span>
                <span id="stat-highest-score" style="color: gold;">0</span>
            </div>
            <div style="color: #00f2ff; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: space-between;">
                <span>Total Deaths:</span>
                <span id="stat-total-deaths" style="color: #ff0000;">0</span>
            </div>
            <div style="color: #00f2ff; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: space-between;">
                <span>Snakes Killed:</span>
                <span id="stat-snakes-killed" style="color: #2bff00;">0</span>
            </div>
            <div style="color: #00f2ff; font-size: 1.2rem; margin-bottom: 20px; display: flex; justify-content: space-between;">
                <span>Longest Leader Time:</span>
                <span id="stat-longest-leader" style="color: gold;">0s</span>
            </div>
            <div style="color: #00f2ff; font-size: 1.2rem; display: flex; justify-content: space-between;">
                <span>Games Played:</span>
                <span id="stat-games-played" style="color: #fff;">0</span>
            </div>
        </div>
        
        <button class="menu-btn" style="margin-top: 30px;" onclick="resetStats()">RESET STATS</button>
    </div>
</div>

<div id="game-wrapper">
    <div id="top-area" class="screen">
        <button class="exit-btn" id="p1-exit" onclick="pauseGame(1)">PAUSE</button>
        <div id="p1-ui-container" class="ui-container">
            <div id="p1-ui" class="ui">YOU: 0</div>
        </div>
                <button id="p1-emp-btn" class="ability-btn emp-style" onpointerdown="event.stopPropagation(); triggerEMP(1)">EMP</button>
<button id="p1-venom-btn" class="ability-btn venom-style" onpointerdown="event.stopPropagation(); triggerVenom(1)">VENOM</button>
<button id="p1-ghost-btn" class="ability-btn ghost-style" onpointerdown="event.stopPropagation(); triggerGhost(1)">GHOST</button>
<button id="p1-gravity-btn" class="ability-btn gravity-style" onpointerdown="event.stopPropagation(); triggerGravity(1)">GRAVITY</button>
<button id="p1-boost-btn" class="ability-btn boost-style" onpointerdown="event.stopPropagation(); triggerBoost(1)">BOOST</button>
<button id="p1-killshot-btn" class="ability-btn killshot-style" onpointerdown="event.stopPropagation(); triggerKillshot(1)">KILL</button>
        
        <div id="p1-board" class="leaderboard"><div class="lb-title">Leaderboard</div><div class="lb-list"></div></div>
                <div id="p1-pause" class="menu-overlay pause-menu">
    <div>PAUSED</div>
    <button class="menu-btn" onclick="resumeGame()">RESUME</button>
    <button class="menu-btn" onclick="goToMenu()">MENU</button>
</div>
                        <div id="p1-over" class="menu-overlay respawn-menu">
    <div>GET SNEKED</div>
    <button class="respawn-btn" onpointerdown="event.stopPropagation(); event.preventDefault(); restartGame(1)">RESPAWN</button>
</div>
        <canvas id="canvas1"></canvas>
    </div>
    <div id="bottom-area" class="screen">
        <button class="exit-btn" id="p2-exit" onclick="pauseGame(2)">PAUSE</button>
        <div id="p2-ui-container" class="ui-container p2-ui-pos">
            <div id="p2-ui" class="ui">ISAAC: 0</div>
        </div>
        <button id="p2-emp-btn" class="ability-btn emp-style" onpointerdown="event.stopPropagation(); triggerEMP(2)">EMP</button>
<button id="p2-venom-btn" class="ability-btn venom-style" onpointerdown="event.stopPropagation(); triggerVenom(2)">VENOM</button>
<button id="p2-ghost-btn" class="ability-btn ghost-style" onpointerdown="event.stopPropagation(); triggerGhost(2)">GHOST</button>
<button id="p2-gravity-btn" class="ability-btn gravity-style" onpointerdown="event.stopPropagation(); triggerGravity(2)">GRAVITY</button>
<button id="p2-boost-btn" class="ability-btn boost-style" onpointerdown="event.stopPropagation(); triggerBoost(2)">BOOST</button>
<button id="p2-killshot-btn" class="ability-btn killshot-style" onpointerdown="event.stopPropagation(); triggerKillshot(2)">KILL</button>

        <div id="p2-board" class="leaderboard"><div class="lb-title">Leaderboard</div><div class="lb-list"></div></div>
                <div id="p2-pause" class="menu-overlay pause-menu">
    <div>PAUSED</div>
    <button class="menu-btn" onclick="resumeGame()">RESUME</button>
    <button class="menu-btn" onclick="goToMenu()">MENU</button>
</div>
                        <div id="p2-over" class="menu-overlay respawn-menu">
    <div>GET SNEKED</div>
    <button class="respawn-btn" onpointerdown="event.stopPropagation(); event.preventDefault(); restartGame(2)">RESPAWN</button>
</div>
        <canvas id="canvas2"></canvas>
    </div>
</div>

<script>
const WORLD = { width: 3000, height: 3000 };
const BORDER_PADDING = 40;
const CONFIG = { 
    startSpeed: 3.57, 
    minSpeed: 2.10,   
    speedDropFactor: 0.35, 
    growthRate: 0.40, 
    initialLength: 30, 
    foodCount: 600, 
    AI_COUNT: 30, 
    collisionMargin: 12, 
    ghostDuration: 3000, 
    rotationSpeed: 0.20,
    //Player Turning Controls
    playerRotationSpeed: 0.55,
    playerMaxTurn: 0.55,
    playerHardTurnBoost: 1.5,
    playerMinTurn: 0.15,
    empCooldown: 60000,
    venomCooldown: 60000,
    ghostCooldown: 60000,
    ghostActiveDuration: 5000,
    gravityCooldown: 60000,
    gravityActiveDuration: 5000,
    empSlowDuration: 10000,
    venomProjectileSpeed: 13.5,
    boostCooldown: 60000,
    boostActiveDuration: 3000,
    boostSpeedMultiplier: 3,
    killshotCooldown: 60000,
    killshotActiveDuration: 5000,
    AI_DASH_DURATION: 3000,
    AI_DASH_COOLDOWN: 5000,
    AI_HUNT_LIMIT: 20000,
    AI_CUTOFF_DISTANCE: 700,
    AI_CUTOFF_ANGLE: 1.0,
    AI_CUTOFF_HOLD_TIME: 1500,
    AI_CUTOFF_SAFETY_MULT: 2.5,
    hunterLimit: 100,
    
    // === DIFFICULTY SETTINGS ===
    difficulty: {
        easy: {
            aiCount: 15,
            speedMultiplier: 0.75,  // 25% slower
            hunterLimit: 100,
            playerSpeedMult: 1.0
        },
        normal: {
            aiCount: 30,
            speedMultiplier: 1.0,
            hunterLimit: 100,
            playerSpeedMult: 1.0
        },
        hard: {
            aiCount: 45,
            speedMultiplier: 1.0,
            hunterLimit: 5,
            playerSpeedMult: 1.15  // 15% faster player
        },
        nightmare: {
            aiCount: 60,
            speedMultiplier: 1.0,
            hunterLimit: 6,
            playerSpeedMult: 1.15,
            fogEnabled: true,
            fogVisibleRadius: 400,     // Adjust this for visible area around player
            fogOpacity: 0.85,           // Adjust this for fog darkness (0.0-1.0)
            fogAIOpacity: 0.15          // How visible AI snakes are through fog (0.0-1.0)
        }
    }
};
const AI_NAMES = ["Xenon", "Viper", "Glitch", "Shadow", "Neon", "Zero", "Cipher", "Apex", "Volt", "Ghost", "Rogue", "Orbit", "Pixel", "Laser", "Drift", "Static", "Havoc", "Echo", "Rift", "Nova", "Flux", "Ozone", "Byte", "Ion", "Dusk"];

// === STATS TRACKING ===
let gameStats = {
    highestScore: 0,
    totalDeaths: 0,
    snakesKilled: 0,
    longestLeaderTime: 0, // in milliseconds
    gamesPlayed: 0
};

let currentLeaderStartTime = 0;
let wasLeaderLastFrame = false;

// Load stats from localStorage
function loadStats() {
    const saved = localStorage.getItem('snekedStats');
    if (saved) {
        try {
            gameStats = JSON.parse(saved);
        } catch (e) {
            console.error('Failed to load stats:', e);
        }
    }
    updateStatsDisplay();
}

// Save stats to localStorage
function saveStats() {
    try {
        localStorage.setItem('snekedStats', JSON.stringify(gameStats));
    } catch (e) {
        console.error('Failed to save stats:', e);
    }
}

// Update stats display
function updateStatsDisplay() {
    document.getElementById('stat-highest-score').textContent = gameStats.highestScore;
    document.getElementById('stat-total-deaths').textContent = gameStats.totalDeaths;
    document.getElementById('stat-snakes-killed').textContent = gameStats.snakesKilled;
    const longestSeconds = Math.floor(gameStats.longestLeaderTime / 1000);
    document.getElementById('stat-longest-leader').textContent = longestSeconds + 's';
    document.getElementById('stat-games-played').textContent = gameStats.gamesPlayed;
}

// Show stats screen
function showStats() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('stats-screen').style.display = 'block';
    updateStatsDisplay();
}

// Back to menu from stats
function backToMainMenuFromStats() {
    document.getElementById('stats-screen').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
}

// Reset all stats
function resetStats() {
    if (confirm('Are you sure you want to reset all stats? This cannot be undone!')) {
        gameStats = {
            highestScore: 0,
            totalDeaths: 0,
            snakesKilled: 0,
            longestLeaderTime: 0,
            gamesPlayed: 0
        };
        saveStats();
        updateStatsDisplay();
    }
}

// Load stats on page load
window.addEventListener('load', loadStats);

let playerSpeedMult = 1.0;        // Global multiplier for player speed
let foods = [];
let allSnakes = [];
let dashParticles = [];
let empPulses = []; 
let venomProjectiles = [];
let greenWalls = [];
let p1, p2;
let leaderId = null;
let gameMode = 1; 
let gameActive = false;
let animationId = null;
let gamePaused = false;
let pauseOwner = null; // 1 or 2 (who triggered pause)
let p1Selected = null;
let p2Selected = null;
let p1Color = null;
let p2Color = null;
let p1Difficulty = 'normal'; // Default difficulty
let p2Difficulty = 'normal'; // Default difficulty
let targetTracker = { p1: 0, p2: 0 };

const canvases = [document.getElementById('canvas1'), document.getElementById('canvas2')];
const uis = [document.getElementById('p1-ui'), document.getElementById('p2-ui')];
const lbLists = [document.querySelector('#p1-board .lb-list'), document.querySelector('#p2-board .lb-list')];

function withVibrate(fn) { if (navigator.vibrate) navigator.vibrate(10); fn(); }
function showControls() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('controls-screen').style.display = 'block';
}

function backToMainMenu() {
    document.getElementById('controls-screen').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
}

function goToNextMenu() {
    document.getElementById('controls-screen').style.display = 'none';
    document.getElementById('next-menu').style.display = 'flex';
}

function backToControls() {
    document.getElementById('next-menu').style.display = 'none';
    document.getElementById('controls-screen').style.display = 'block';
}

function showPowerupSelect(mode) {
    gameMode = mode;
    p1Selected = null; p2Selected = null; p1Color = null; p2Color = null;
    p1Difficulty = 'normal'; // Reset to default
    p2Difficulty = 'normal'; // Reset to default
    
    const powerScreen = document.getElementById('powerup-screen');
    powerScreen.setAttribute('data-mode', mode);
    document.getElementById('menu').style.display = 'none';
    powerScreen.style.display = 'flex';
    const p1Area = document.getElementById('p1-select-area');
    const p2Area = document.getElementById('p2-select-area');
    const divider = document.getElementById('menu-divider');
    
    if (mode === 1) { 
    p1Area.classList.remove('p1-multi-style'); 
    p2Area.style.display = 'none'; 
    divider.style.display = 'none';
    document.getElementById('p1-subtitle').textContent = 'P1: Power-Up & Color';
        // Show P1 colors, Hide P2 colors
        document.getElementById('p1-color-row').style.display = 'flex';
        document.getElementById('p2-color-row').style.display = 'none';
        document.getElementById('p1-back').style.transform = 'rotate(0deg)';
        document.getElementById('p2-back').style.display = 'none';
        
        // Show horizontal difficulty, hide vertical
        document.getElementById('p1-difficulty-row').style.display = 'flex';
        document.getElementById('p1-difficulty-vertical').style.display = 'none';
        document.getElementById('p2-difficulty-vertical').style.display = 'none';
    } else { 
    p1Area.classList.add('p1-multi-style'); 
    p2Area.style.display = 'flex'; 
    divider.style.display = 'block';
    document.getElementById('p1-subtitle').textContent = 'P2: Power-Up & Color';
        // Show BOTH color rows for multiplayer
        document.getElementById('p1-color-row').style.display = 'flex';
        document.getElementById('p2-color-row').style.display = 'flex';
        document.getElementById('p1-back').style.transform = 'rotate(180deg)';
        document.getElementById('p2-back').style.display = 'block';
        
        // Show vertical difficulty buttons, hide horizontal
        document.getElementById('p1-difficulty-row').style.display = 'none';
        document.getElementById('p1-difficulty-vertical').style.display = 'flex';
        document.getElementById('p2-difficulty-vertical').style.display = 'flex';
    }
    
    document.querySelectorAll('.color-box').forEach(b => b.classList.remove('selected'));
    document.querySelectorAll('.power-btn').forEach(btn => btn.classList.remove('selected'));
    
    // Reset difficulty button selections to default (normal)
    document.querySelectorAll('.difficulty-btn, .difficulty-btn-vertical').forEach(btn => {
        if (btn.textContent === 'NORMAL') {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
}

function selectPower(playerNum, choice) {
    if (playerNum === 1) p1Selected = choice;
    if (playerNum === 2) p2Selected = choice;
    const areaId = (playerNum === 1) ? 'p1-select-area' : 'p2-select-area';
    const buttons = document.querySelectorAll(`#${areaId} .power-btn`);
    buttons.forEach((btn, idx) => { if (idx === choice - 1) btn.classList.add('selected'); else btn.classList.remove('selected'); });
    checkStartConditions();
}

function selectColor(playerNum, hex) {
    if (playerNum === 1) p1Color = hex;
    if (playerNum === 2) p2Color = hex;
    const rowId = (playerNum === 1) ? 'p1-color-row' : 'p2-color-row';
    const boxes = document.querySelectorAll(`#${rowId} .color-box`);
    boxes.forEach(box => {
        // This checks if the box's color matches the one you just clicked
        if (box.style.backgroundColor === hex || box.getAttribute('onclick').includes(hex)) box.classList.add('selected');
        else box.classList.remove('selected');
    });
    checkStartConditions();
}
function selectDifficulty(playerNum, difficulty) {
    if (playerNum === 1) {
        p1Difficulty = difficulty;
    } else {
        p2Difficulty = difficulty;
    }
    
    // Update button highlighting
    const containerId = (gameMode === 1 && playerNum === 1) 
        ? 'p1-difficulty-row' 
        : `p${playerNum}-difficulty-vertical`;
    
    const buttons = document.querySelectorAll(`#${containerId} button`);
    buttons.forEach(btn => {
        const btnDifficulty = btn.textContent.toLowerCase();
        if (btnDifficulty === difficulty) {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
    
    checkStartConditions();
}

function checkStartConditions() {
    if (gameMode === 1) {
        // Single player: P1 power + P1 color + P1 difficulty required
        if (p1Selected !== null && p1Color !== null && p1Difficulty !== null) {
            setTimeout(() => startGame(), 300);
        }
        } else {
        // Multiplayer: Both players need power AND color AND difficulty
        if (p1Selected !== null && p1Color !== null && p1Difficulty !== null && 
            p2Selected !== null && p2Color !== null && p2Difficulty !== null) {
            
            // CHECK: Both players must agree on difficulty
            if (p1Difficulty === p2Difficulty) {
                setTimeout(() => startGame(), 300);
            }
        }
    }
}

function startGame() {
    // Track game started
    gameStats.gamesPlayed++;
    saveStats();
    
    // --- DIFFICULTY LOGIC START ---
    const difficultySettings = CONFIG.difficulty[p1Difficulty];
    
    CONFIG.AI_COUNT = difficultySettings.aiCount;
    CONFIG.hunterLimit = difficultySettings.hunterLimit;
    playerSpeedMult = difficultySettings.playerSpeedMult;
    
    // Apply speed multiplier
    CONFIG.startSpeed = 3.57 * difficultySettings.speedMultiplier;
    CONFIG.minSpeed = 2.10 * difficultySettings.speedMultiplier;
    // --- DIFFICULTY LOGIC END ---

    document.getElementById('powerup-screen').style.display = 'none';
    document.getElementById('game-wrapper').style.display = 'flex';
    init();
    
    const p1Cont = document.getElementById('p1-ui-container');
    const p1Btns = [
    document.getElementById('p1-emp-btn'), 
    document.getElementById('p1-venom-btn'), 
    document.getElementById('p1-ghost-btn'),
    document.getElementById('p1-gravity-btn'),
    document.getElementById('p1-boost-btn'),
    document.getElementById('p1-killshot-btn')
];
const p2Btns = [
    document.getElementById('p2-emp-btn'), 
    document.getElementById('p2-venom-btn'), 
    document.getElementById('p2-ghost-btn'),
    document.getElementById('p2-gravity-btn'),
    document.getElementById('p2-boost-btn'),
    document.getElementById('p2-killshot-btn')
];

    p1Btns.forEach((btn, idx) => {
        btn.style.display = (p1Selected === idx + 1) ? 'block' : 'none';
        btn.classList.remove('cooldown');
        if (gameMode === 1) {
            btn.classList.add('p1-ui-sp-btn');
            btn.classList.remove('p1-ui-mp-btn');
        } else {
            btn.classList.remove('p1-ui-sp-btn');
            btn.classList.add('p1-ui-mp-btn');
        }
    });

        if (gameMode === 2) {
        p2Btns.forEach((btn, idx) => {
            btn.style.display = (p2Selected === idx + 1) ? 'block' : 'none';
            btn.classList.remove('cooldown');
            btn.classList.add('p2-ui-mp-btn');
        });
        document.getElementById('bottom-area').style.display = 'block';
        p1Cont.className = "ui-container p1-ui-mp"; 
        document.getElementById('p1-board').classList.add('p1-board-rotate', 'multi');
        document.getElementById('p1-exit').classList.add('multi-exit');
        // Fix: Rotate P1 respawn screen only for Multiplayer
                document.getElementById('p1-over').style.transform = 'translate(-50%, -50%) rotate(180deg)';
        document.getElementById('p1-pause').style.transform = 'translate(-50%, -50%) rotate(180deg)';
document.getElementById('p2-pause').style.transform = 'translate(-50%, -50%) rotate(0deg)';
    } else {
        p2Btns.forEach(btn => btn.style.display = 'none');
        document.getElementById('bottom-area').style.display = 'none';
        p1Cont.className = "ui-container p1-ui-sp"; 
        document.getElementById('p1-board').classList.remove('p1-board-rotate', 'multi');
        document.getElementById('p1-exit').classList.remove('multi-exit');
        // Fix: Reset P1 respawn screen to normal for Single Player
                document.getElementById('p1-over').style.transform = 'translate(-50%, -50%) rotate(0deg)';
        document.getElementById('p1-pause').style.transform = 'translate(-50%, -50%) rotate(0deg)';
    }
    
    window.dispatchEvent(new Event('resize'));
    gameActive = true; loop();
}

function triggerEMP(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.empCooldownEnd) return;
    user.empCooldownEnd = Date.now() + CONFIG.empCooldown;
    const btn = document.getElementById(`p${playerId}-emp-btn`);
    if(btn) btn.classList.add('cooldown');
    empPulses.push({ x: user.x, y: user.y, radius: 0, maxRadius: 1000, alpha: 1.0, color: "#00f2ff" });
    const canvas = canvases[playerId - 1];
    const halfW = canvas.width / 2;
    const halfH = canvas.height / 2;
    allSnakes.forEach(s => {
        if (s === user || s.dead) return;
        const dx = Math.abs(s.x - user.x);
        const dy = Math.abs(s.y - user.y);
        if (dx < halfW + 100 && dy < halfH + 100) {
            s.slowedUntil = Date.now() + CONFIG.empSlowDuration;
        }
    });
}

function triggerVenom(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.venomCooldownEnd) return;
    user.venomCooldownEnd = Date.now() + CONFIG.venomCooldown;
    const btn = document.getElementById(`p${playerId}-venom-btn`);
    if(btn) btn.classList.add('cooldown');
    let count = 0;
    const fireInterval = setInterval(() => {
        if(!user.dead && gameActive && count < 5) {
            venomProjectiles.push({
                x: user.x, y: user.y, angle: user.angle, speed: CONFIG.venomProjectileSpeed, radius: 7, owner: user
            });
            count++;
        } else {
            clearInterval(fireInterval);
        }
    }, 80);
}

function triggerGhost(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.ghostCooldownEnd) return;
    user.ghostUntil = Date.now() + CONFIG.ghostActiveDuration;
    user.ghostCooldownEnd = Date.now() + CONFIG.ghostCooldown;
    const btn = document.getElementById(`p${playerId}-ghost-btn`);
    if(btn) btn.classList.add('cooldown');
}

function triggerGravity(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.gravityCooldownEnd) return;

    user.gravityCooldownEnd = Date.now() + CONFIG.gravityCooldown;
    const btn = document.getElementById(`p${playerId}-gravity-btn`);
    if (btn) btn.classList.add('cooldown');

    // 1. Activate the 5-second window for the swirl and suction
    user.gravityActiveUntil = Date.now() + CONFIG.gravityActiveDuration;
    
    const canvas = canvases[playerId - 1];
    const halfW = canvas.width / 2;
    const halfH = canvas.height / 2;

    // 2. Instead of eating instantly, flag food to be sucked in
    foods.forEach(f => {
        if (Math.abs(f.x - user.x) < halfW && Math.abs(f.y - user.y) < halfH) {
            f.beingSuckedBy = user; // This flags the food for the update loop
        }
    });
}
function triggerBoost(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.boostCooldownEnd) return;

    user.boostActiveUntil = Date.now() + CONFIG.boostActiveDuration;
    user.boostCooldownEnd = Date.now() + CONFIG.boostCooldown;

    const btn = document.getElementById(`p${playerId}-boost-btn`);
    if (btn) btn.classList.add('cooldown');
}

function triggerKillshot(playerId) {
    const user = (playerId === 1) ? p1 : p2;
    if (user.dead || Date.now() < user.killshotCooldownEnd) return;

    user.killshotActiveUntil = Date.now() + CONFIG.killshotActiveDuration;
    user.killshotCooldownEnd = Date.now() + CONFIG.killshotCooldown;

    const btn = document.getElementById(`p${playerId}-killshot-btn`);
    if (btn) btn.classList.add('cooldown');
}

function applyBoostShockwave(boostingSnake) {
    // Increased Range (6 -> 8) and Force (18 -> 35) to "Part the Seas"
    const SHOCKWAVE_DIST = boostingSnake.width * 8; 
    const PUSH_FORCE = 35;
    
    for (let other of allSnakes) {
        if (other === boostingSnake || other.dead || Date.now() < other.ghostUntil) continue;
        
        const dx = other.x - boostingSnake.x;
        const dy = other.y - boostingSnake.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < SHOCKWAVE_DIST && dist > 0) {
            // Calculate perpendicular direction (left/right relative to boost direction)
            const boostDirX = Math.cos(boostingSnake.angle);
            const boostDirY = Math.sin(boostingSnake.angle);
            
            // Dot product to find if other snake is left or right
            const cross = dx * boostDirY - dy * boostDirX;
            
            // Push perpendicular
            const pushAngle = boostingSnake.angle + (cross > 0 ? Math.PI/2 : -Math.PI/2);
            
            // Apply force (stronger when closer)
            const forceMult = 1 - (dist / SHOCKWAVE_DIST);
            other.x += Math.cos(pushAngle) * PUSH_FORCE * forceMult;
            other.y += Math.sin(pushAngle) * PUSH_FORCE * forceMult;
        }
    }
}

function getRandomPos() { return { x: BORDER_PADDING + Math.random() * (WORLD.width - BORDER_PADDING * 2), y: BORDER_PADDING + Math.random() * (WORLD.height - BORDER_PADDING * 2) }; }

class Snake {
    constructor(id, x, y, color, name, isAI = false) {
        this.id = id; this.color = color; this.name = name; this.isAI = isAI;
        this.joystick = { active: false, id: null, startX: 0, startY: 0, currX: 0, currY: 0 };
        this.dashId = null; 
        this.isHunter = isAI && (id % 4 === 0); 
        this.isCivilWarAI = isAI && !this.isHunter && (id % 2 === 0); // 50% of non-player-hunters target AI
        this.isTrapping = false;
        this.coilTarget = null;
        this.coilRecoverUntil = 0;
        this.slowedUntil = 0;
        this.empCooldownEnd = 0;
        this.venomCooldownEnd = 0;
        this.ghostCooldownEnd = 0;
        this.gravityCooldownEnd = 0;
        this.boostCooldownEnd = 0;
        this.boostActiveUntil = 0;
        this.killshotCooldownEnd = 0;
        this.killshotActiveUntil = 0;
        this.dashStartTime = 0;
        this.dashCooldownUntil = 0;
        this.huntStartTime = 0;
        this.huntCooldownUntil = 0;
        this.currentlyChasing = null;
        this.hunterSpeedBoost = 1.0;
        this.cutoffTimer = 0; 
        this.cutoffAngle = null;
        this.leaderAlpha = 0;
        this.reset(x, y);
    }
        reset(x, y) {
        this.x = x; this.y = y; this.dead = false; this.ghostUntil = Date.now() + CONFIG.ghostDuration;
        this.angle = Math.random() * Math.PI * 2; this.length = CONFIG.initialLength;
        this.tail = []; this.score = 0; this.isDashing = false; this.width = 6;
        this.empCooldownEnd = 0;
        this.venomCooldownEnd = 0;
        this.ghostCooldownEnd = 0;
        this.gravityCooldownEnd = 0; 
        this.gravityActiveUntil = 0;
        this.boostCooldownEnd = 0;
        this.boostActiveUntil = 0;
        this.killshotCooldownEnd = 0;
        this.killshotActiveUntil = 0;
        this.dashStartTime = 0;
        this.dashCooldownUntil = 0;
        this.huntStartTime = 0;
        this.huntCooldownUntil = 0;
        this.currentlyChasing = null;
        this.hunterSpeedBoost = 1.0;
        this.cutoffTimer = 0; 
        this.cutoffAngle = null;
        if (!this.isAI) {
    const eBtn = document.getElementById(`p${this.id}-emp-btn`);
    const vBtn = document.getElementById(`p${this.id}-venom-btn`);
    const gBtn = document.getElementById(`p${this.id}-ghost-btn`);
    const grBtn = document.getElementById(`p${this.id}-gravity-btn`);
    const bBtn = document.getElementById(`p${this.id}-boost-btn`);
    const kBtn = document.getElementById(`p${this.id}-killshot-btn`);
    if(eBtn) eBtn.classList.remove('cooldown');
    if(vBtn) vBtn.classList.remove('cooldown');
    if(gBtn) gBtn.classList.remove('cooldown');
    if(grBtn) grBtn.classList.remove('cooldown');
    if(bBtn) bBtn.classList.remove('cooldown');
    if(kBtn) kBtn.classList.remove('cooldown');
}
    }
    update() {
        if (this.dead) return;
        this.score = Math.max(0, Math.floor((this.length - CONFIG.initialLength) * 2));
        
                // Force Leader to always be a Hunter
        if (this.isAI && this.id === leaderId) {
            this.isHunter = true;
        }

        if (this.isAI && this.score >= 250) {
            this.isHunter = true;
        }

        const weightEffect = Math.log10(1 + (this.score / 120)) * CONFIG.speedDropFactor;
                let speed = Math.max(CONFIG.minSpeed, CONFIG.startSpeed - weightEffect);
        
        // Apply Hard Mode Player Speed Boost
        if (!this.isAI && playerSpeedMult !== 1.0) {
            speed *= playerSpeedMult;
        }
const wasBoosting = Date.now() < this.boostActiveUntil;
if (wasBoosting) {
    speed *= CONFIG.boostSpeedMultiplier;
    if (!this.isAI) {
        applyBoostShockwave(this); // Apply shockwave every frame while boosting
    }
}
        if (Date.now() < this.slowedUntil) speed *= 0.25;
                // Smooth Leader Transition
        const targetLeaderAlpha = (this.id === leaderId && this.score > 0) ? 1.0 : 0.0;
        if (this.leaderAlpha < targetLeaderAlpha) this.leaderAlpha += 0.03; 
        else if (this.leaderAlpha > targetLeaderAlpha) this.leaderAlpha -= 0.03;
        this.leaderAlpha = Math.max(0, Math.min(1, this.leaderAlpha));

                if (this.isAI) { this.handleAIBehavior(speed); } 
        else if (this.joystick.active) {
            const dx = this.joystick.currX - this.joystick.startX;
            const dy = this.joystick.currY - this.joystick.startY;

            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 6) {
                const target = Math.atan2(dy, dx);
                let diff = target - this.angle;

                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                // Normalize joystick strength (0 â†’ 1)
                const inputStrength = Math.min(1, mag / 80);

                // Dynamic turn speed (PLAYER ONLY)
                let turnSpeed = CONFIG.playerRotationSpeed;
                if (inputStrength > 0.85) {
                    turnSpeed *= CONFIG.playerHardTurnBoost;
                }

                // Apply rotation with hard clamp
                let rawTurn = Math.abs(diff * turnSpeed);

                // Force a minimum turn when input is strong
                if (inputStrength > 0.6) {
                    rawTurn = Math.max(rawTurn, CONFIG.playerMinTurn);
                }

                const turn = Math.sign(diff) * Math.min(
                    rawTurn,
                    CONFIG.playerMaxTurn
                );

                this.angle += turn;
            }
        }


        if (this.isAI && this.isDashing) {
            if (this.dashStartTime === 0) this.dashStartTime = Date.now();
            if (Date.now() - this.dashStartTime > CONFIG.AI_DASH_DURATION) {
                this.isDashing = false;
                this.dashStartTime = 0;
                this.dashCooldownUntil = Date.now() + CONFIG.AI_DASH_COOLDOWN;
            }
        } else if (this.isAI) {
            this.dashStartTime = 0;
        }

        if (this.isDashing && this.length > 20) { 
            speed *= 1.7 * this.hunterSpeedBoost; this.length -= 0.15; 
            if (Math.random() > 0.3) dashParticles.push({ x: this.x, y: this.y, color: this.color, w: this.width, life: 1.0 }); 
        } else { this.isDashing = false; }
        
        this.width = Math.min(25, 6 + (Math.log10(1 + this.score/30) * 14));
        this.x += Math.cos(this.angle) * speed; this.y += Math.sin(this.angle) * speed;
        
        if (!this.isAI) {
    if (this.empCooldownEnd > 0 && Date.now() >= this.empCooldownEnd) {
        const eBtn = document.getElementById(`p${this.id}-emp-btn`);
        if(eBtn) eBtn.classList.remove('cooldown');
        this.empCooldownEnd = 0;
    }
    if (this.venomCooldownEnd > 0 && Date.now() >= this.venomCooldownEnd) {
        const vBtn = document.getElementById(`p${this.id}-venom-btn`);
        if(vBtn) vBtn.classList.remove('cooldown');
        this.venomCooldownEnd = 0;
    }
    if (this.ghostCooldownEnd > 0 && Date.now() >= this.ghostCooldownEnd) {
        const gBtn = document.getElementById(`p${this.id}-ghost-btn`);
        if(gBtn) gBtn.classList.remove('cooldown');
        this.ghostCooldownEnd = 0;
    }
    if (this.gravityCooldownEnd > 0 && Date.now() >= this.gravityCooldownEnd) {
        const gBtn = document.getElementById(`p${this.id}-gravity-btn`);
        if (gBtn) gBtn.classList.remove('cooldown');
        this.gravityCooldownEnd = 0;
    }
    if (this.boostCooldownEnd > 0 && Date.now() >= this.boostCooldownEnd) {
        const bBtn = document.getElementById(`p${this.id}-boost-btn`);
        if (bBtn) bBtn.classList.remove('cooldown');
        this.boostCooldownEnd = 0;
    }
    if (this.killshotCooldownEnd > 0 && Date.now() >= this.killshotCooldownEnd) {
        const kBtn = document.getElementById(`p${this.id}-killshot-btn`);
        if (kBtn) kBtn.classList.remove('cooldown');
        this.killshotCooldownEnd = 0;
    }
}

                if (this.x < 0 || this.x > WORLD.width || this.y < 0 || this.y > WORLD.height) { this.die(); return; }

                // --- COLLISION LOGIC: Only Ghost and Killshot provide immunity ---
if (Date.now() > this.ghostUntil && Date.now() > this.killshotActiveUntil) {
    for (let other of allSnakes) {
        if (other.dead || Date.now() < other.ghostUntil || other === this) continue;
        const endIdx = other.tail.length;
        for (let i = 0; i < endIdx; i += 3) {
            const seg = other.tail[i];
            if(!seg) continue;
            const distSq = (this.x - seg.x)**2 + (this.y - seg.y)**2;
            const limit = (this.width/2 + seg.w/2) * 0.85; 
            if (distSq < limit * limit) { 
                // Track kills: if an AI snake dies by hitting a player's tail
                if (this.isAI && !other.isAI) {
                    gameStats.snakesKilled++;
                    saveStats();
                }
                this.die(); 
                return; 
            }
        }
    }
}

        this.tail.push({x: this.x, y: this.y, w: this.width}); 
        while (this.tail.length > this.length) this.tail.shift();
                        // --- UPDATED GRAVITY SUCTION ANIMATION ---
        const isGravityActive = Date.now() < this.gravityActiveUntil;

        foods.forEach(f => {
            if (f.beingSuckedBy === this) {
                // If the power-up has expired, stop sucking this food
                if (!isGravityActive) {
                    f.beingSuckedBy = null;
                    return;
                }

                const dx = this.x - f.x;
                const dy = this.y - f.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    // Pull speed follows the fade (starts at 0, ramps to 12, fades to 0)
                    const gTimeLeft = this.gravityActiveUntil - Date.now();
                    const gElapsed = CONFIG.gravityActiveDuration - gTimeLeft;
                    let gFade = (gElapsed < 1000) ? gElapsed / 1000 : (gTimeLeft < 1000 ? gTimeLeft / 1000 : 1);
                    
                    const pullSpeed = 12 * gFade; 
                    f.x += (dx / dist) * pullSpeed;
                    f.y += (dy / dist) * pullSpeed;
                }
            }
        });

        for (let i = foods.length - 1; i >= 0; i--) { 
    const f = foods[i]; 
    const dSq = (this.x - f.x)**2 + (this.y - f.y)**2; 
    if (dSq < (22 + this.width/2)**2) { 
        // AI snakes grow faster
        const aiGrowth = this.isAI ? 1.5 : 1.0; // AI gets 50% more growth
        this.length += CONFIG.growthRate * f.growthMult * aiGrowth;

        if (!f.isTemp) { 
            const pos = getRandomPos(); 
            f.x = pos.x; 
            f.y = pos.y; 
        } else { 
            foods.splice(i, 1); 
        } 
    } 
  }
// Killshot: Eat other snakes
if (Date.now() < this.killshotActiveUntil) {
    for (let other of allSnakes) {
        if (other === this || other.dead) continue;
        
        // Check if player ate another snake's head (instant kill)
        const headDistSq = (this.x - other.x)**2 + (this.y - other.y)**2;
        const headEatRadius = (this.width/2 + other.width/2 + 8);
        
        if (headDistSq < headEatRadius * headEatRadius) {
            // Instant kill - eat the head
            other.die();
            this.length += 10; // Bonus for eating head
            continue;
        }
        
        // Check tail segments for eating (consume gradually as you move)
        let segmentsEaten = 0;
        for (let i = other.tail.length - 1; i >= 0; i--) {
            const seg = other.tail[i];
            if (!seg) continue;
            
            const distSq = (this.x - seg.x)**2 + (this.y - seg.y)**2;
                // Reduced radius (-5 instead of +3) so you must overlap deeply to eat
    const eatRadius = (this.width/2 + seg.w/2 - 5);
            
                        if (distSq < eatRadius * eatRadius) {
                // Remove this single segment
                const eatenSeg = other.tail.splice(i, 1)[0];
                other.length = Math.max(0, other.length - 1);
                segmentsEaten++;
                
                // Blocky Animation: Add square particles (LARGER & MORE)
if (eatenSeg) {
   for(let k=0; k<8; k++) { // Increased from 3 to 8
       dashParticles.push({
           x: eatenSeg.x + (Math.random()-0.5)*20, // More spread
           y: eatenSeg.y + (Math.random()-0.5)*20,
           color: other.color,
           w: other.width * 1.3, // Much larger (was divided by 1.5, now multiplied)
           life: 1.0,
           shape: 'rect'
       });
   }
}
                
                // 1:1 length transfer
                this.length += 1;
                
                // If snake has very few segments left, it dies
                if (other.tail.length < 3) {
                    other.die();
                    break;
                }
            }
        }
    }
}
}

            handleAIBehavior(speed) {
    let immediateDanger = false;
    
    // ============================================================
// PRIORITY 1: WALL AVOIDANCE (FIXED)
// ============================================================
const wallLookAhead = 300; // Increased from 200
const wallCheckX = this.x + Math.cos(this.angle) * wallLookAhead;
const wallCheckY = this.y + Math.sin(this.angle) * wallLookAhead;

// Check if we're heading toward a wall
if(wallCheckX < 150 || wallCheckX > WORLD.width - 150 || 
   wallCheckY < 150 || wallCheckY > WORLD.height - 150) { 
    
    if (!this.isTrapping) {
        const angleToCenter = Math.atan2(WORLD.height/2 - this.y, WORLD.width/2 - this.x);
        let diff = angleToCenter - this.angle;
        while (diff < -Math.PI) diff += Math.PI * 2; 
        while (diff > Math.PI) diff -= Math.PI * 2;
        
        // Much stronger turn toward center
        this.angle += Math.sign(diff) * 0.8; // Increased from 0.5
        immediateDanger = true;
        this.isDashing = false; // Stop dashing when avoiding walls
    }
}

// Emergency wall escape - trigger earlier and more aggressively
if (this.x < 120 || this.x > WORLD.width - 120 || 
    this.y < 120 || this.y > WORLD.height - 120) {
    // Point directly to center
    this.angle = Math.atan2(WORLD.height/2 - this.y, WORLD.width/2 - this.x);
    this.isDashing = false;
    immediateDanger = true;
    return;
}

    // ============================================================
    // PRIORITY 2: TAIL COLLISION AVOIDANCE (FIXED)
    // ============================================================
    if (!immediateDanger && !this.isTrapping) {
        for (let other of allSnakes) { 
            if (other.dead || other === this || Date.now() < other.ghostUntil) continue;
            if (Math.abs(other.x - this.x) > 600 || Math.abs(other.y - this.y) > 600) continue;
            
            for (let i = 0; i < other.tail.length; i += 5) { 
                const seg = other.tail[i]; 
                if (!seg) continue;
                
                const distSq = (this.x - seg.x)**2 + (this.y - seg.y)**2; 
                const dangerZone = (this.width + other.width + 60)**2; 
                
                if (distSq < dangerZone) { 
                    const angleToSeg = Math.atan2(seg.y - this.y, seg.x - this.x); 
                    let diff = angleToSeg - this.angle; 
                    while (diff < -Math.PI) diff += Math.PI * 2; 
                    while (diff > Math.PI) diff -= Math.PI * 2; 
                    this.angle -= Math.sign(diff) * 0.7;
                    immediateDanger = true;
                    
                    const criticalZone = (this.width + other.width + 30)**2;
                    if (distSq < criticalZone) {
                        this.isDashing = false;
                        this.angle -= Math.sign(diff) * 1.0;
                        return;
                    }
                    break; 
                } 
            } 
            if (immediateDanger) break; 
        }
    }

    // ============================================================
    // PRIORITY 3: PREDICTIVE COLLISION AVOIDANCE (NEW)
    // ============================================================
    if (!immediateDanger && !this.isTrapping) {
        const predictSteps = 8;
        const predictSpeed = speed * 1.5;
        
        for (let step = 1; step <= predictSteps; step++) {
            const futureX = this.x + Math.cos(this.angle) * (predictSpeed * step);
            const futureY = this.y + Math.sin(this.angle) * (predictSpeed * step);
            
            for (let other of allSnakes) {
                if (other.dead || other === this || Date.now() < other.ghostUntil) continue;
                if (Math.abs(other.x - this.x) > 700) continue;
                
                for (let i = 0; i < other.tail.length; i += 8) {
                    const seg = other.tail[i];
                    if (!seg) continue;
                    
                    const futureDist = (futureX - seg.x)**2 + (futureY - seg.y)**2;
                    const safetyMargin = (this.width + other.width + 70)**2;
                    
                    if (futureDist < safetyMargin) {
                        const avoidAngle = Math.atan2(seg.y - this.y, seg.x - this.x);
                        let diff = avoidAngle - this.angle;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        this.angle -= Math.sign(diff) * 0.8;
                        immediateDanger = true;
                        break;
                    }
                }
                if (immediateDanger) break;
            }
            if (immediateDanger) break;
        }
    }

    // ============================================================
    // COIL ZONE ESCAPE (IMPROVED)
    // ============================================================
    for (let other of allSnakes) {
        if (other === this || other.dead || !other.isTrapping) continue;
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const distSq = dx * dx + dy * dy;
        
        const avoidRadius = (other.trapRadius || 300) + 500; 
        
        if (distSq < avoidRadius * avoidRadius) {
            const escapeAngle = Math.atan2(dy, dx);
            let diff = escapeAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            
            this.angle += diff * 0.7;
            this.isDashing = true;
            return; 
        }
    }
    
    // ============================================================
    // UNIVERSAL PLAYER CUTOFF (UNCHANGED)
    // ============================================================
    const players = [p1, p2].filter(p => p && !p.dead && Date.now() > p.ghostUntil);
    let cutoffTarget = null;

    for (let p of players) {
        const dx = p.x - this.x;
        const dy = p.y - this.y;
        const distSq = dx*dx + dy*dy;
        if (distSq < CONFIG.AI_CUTOFF_DISTANCE**2) { 
            const dot = dx * Math.cos(this.angle) + dy * Math.sin(this.angle);
            if (dot < -20) {
                cutoffTarget = p;
                break; 
            }
        }
    }

    let isPathBlocked = false;
    const testAngle = this.cutoffAngle || this.angle;
    const safetyDist = this.width * CONFIG.AI_CUTOFF_SAFETY_MULT;
    const checkX = this.x + Math.cos(testAngle) * safetyDist;
    const checkY = this.y + Math.sin(testAngle) * safetyDist;

    if (checkX < 50 || checkX > WORLD.width - 50 || checkY < 50 || checkY > WORLD.height - 50) {
        isPathBlocked = true;
    }

    if (!isPathBlocked) {
        for (let other of allSnakes) {
            if (other.dead || Date.now() < other.ghostUntil) continue;
            if (Math.abs(other.x - this.x) > 400 || Math.abs(other.y - this.y) > 400) continue;
            for (let i = 0; i < other.tail.length; i += 8) {
                const seg = other.tail[i];
                if ((checkX - seg.x)**2 + (checkY - seg.y)**2 < (this.width + other.width + 15)**2) {
                    isPathBlocked = true;
                    break;
                }
            }
            if (isPathBlocked) break;
        }
    }

    if (!isPathBlocked && (cutoffTarget || Date.now() < this.cutoffTimer)) {
        if (Date.now() > this.cutoffTimer && cutoffTarget) {
            const angleToP = Math.atan2(cutoffTarget.y - this.y, cutoffTarget.x - this.x);
            let diff = angleToP - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.cutoffAngle = this.angle + (Math.sign(diff) * CONFIG.AI_CUTOFF_ANGLE);
            this.cutoffTimer = Date.now() + CONFIG.AI_CUTOFF_HOLD_TIME;
        }
        if (Date.now() < this.cutoffTimer) {
            this.angle = this.cutoffAngle;
            this.isDashing = true;
            return;
        }
    } else {
        this.cutoffTimer = 0; 
        this.cutoffAngle = null;
    }

    // ============================================================
    // HUNTING & COILING LOGIC (UNCHANGED EXCEPT SAFETY FIXES)
    // ============================================================
    if (!immediateDanger) {
        let targetX = null, targetY = null;
        let targetSnake = null;

        if (this.isHunter) {
            targetSnake = (gameMode === 2 && Math.random() > 0.5) ? p2 : p1;
        } else if (this.isCivilWarAI) {
            let potential = allSnakes.filter(s => s !== this && !s.dead && Date.now() > s.ghostUntil);
            if (potential.length > 0) targetSnake = potential[0];
        }

        const distToTarget = targetSnake ? Math.sqrt((this.x - targetSnake.x)**2 + (this.y - targetSnake.y)**2) : 9999;
        const canHunt = Date.now() > this.huntCooldownUntil;

        if ((this.isHunter || this.isCivilWarAI) && canHunt && targetSnake && !targetSnake.dead && Date.now() > targetSnake.ghostUntil && distToTarget < 1200) {
            
            let allowedToHunt = true;
            if (this.huntStartTime === 0 && CONFIG.hunterLimit < 20) {
                let othersHunting = 0;
                for (let s of allSnakes) {
                    if (s !== this && s.isAI && s.currentlyChasing === targetSnake) {
                        othersHunting++;
                    }
                }
                if (othersHunting >= CONFIG.hunterLimit) allowedToHunt = false;
            }

            if (allowedToHunt) {
                if (this.huntStartTime === 0) this.huntStartTime = Date.now();
                this.currentlyChasing = targetSnake;

                if (distToTarget < this.width) {
                    this.huntStartTime = Date.now(); 
                }

                if (Date.now() - this.huntStartTime > CONFIG.AI_HUNT_LIMIT) {
                    this.huntCooldownUntil = Date.now() + 8000;
                    this.huntStartTime = 0;
                    this.isDashing = false;
                    this.isTrapping = false; 
                    this.coilTarget = null;
                    this.stopChasing();
                } else {
                    const canDash = Date.now() > this.dashCooldownUntil;
                    const sizeFactor = Math.max(0.25, 1.0 - (this.score / 450));
                    const distanceFactor = distToTarget < 600 ? 1.0 : 0.4;
                    const dashChance = 0.018 * sizeFactor * distanceFactor;

                    this.isDashing = canDash && (
                        distToTarget < 250 || Math.random() < dashChance
                    );

                    // ============================================================
                    // SAFETY CHECK: Don't dash into obstacles (NEW)
                    // ============================================================
                    if (this.isDashing && !this.isTrapping) {
                        const dashCheckDist = this.width * 4;
                        const dashCheckX = this.x + Math.cos(this.angle) * dashCheckDist;
                        const dashCheckY = this.y + Math.sin(this.angle) * dashCheckDist;
                        
                        for (let other of allSnakes) {
                            if (other === this || other.dead || Date.now() < other.ghostUntil) continue;
                            for (let i = 0; i < other.tail.length; i += 6) {
                                const seg = other.tail[i];
                                if (!seg) continue;
                                const checkDist = (dashCheckX - seg.x)**2 + (dashCheckY - seg.y)**2;
                                if (checkDist < (this.width + other.width + 40)**2) {
                                    this.isDashing = false;
                                    break;
                                }
                            }
                        }
                    }

                    if (this.isHunter && this.isDashing && targetSnake && !targetSnake.isAI && distToTarget < 250) {
                        this.hunterSpeedBoost = 1.25;
                    } else {
                        this.hunterSpeedBoost = 1.0;
                    }

                    const relX = targetSnake.x - this.x;
                    const relY = targetSnake.y - this.y;
                    const forwardX = Math.cos(this.angle);
                    const forwardY = Math.sin(this.angle);
                    const dot = relX * forwardX + relY * forwardY;
                    const isAheadOfPlayer = dot < -30;

                    if (isAheadOfPlayer && distToTarget < 280) {
                        const angleToTarget = Math.atan2(relY, relX);
                        let diff = angleToTarget - this.angle;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        this.angle += Math.sign(diff) * 0.5;
                        this.isDashing = true; 
                    } 
                    else if (this.score >= 150 && targetSnake) {
                        const playerKey = (targetSnake === p1) ? "p1" : "p2";

                        if (targetTracker[playerKey] && targetTracker[playerKey] !== this.id) {
                            return;
                        }

                        targetTracker[playerKey] = this.id;

                        this.isTrapping = true;
                        this.coilTarget = targetSnake;
                        if (!this.trapRadius) this.trapRadius = 300;

                        const minRadius = (this.width * 2.2) + (targetSnake.width * 2.2) + 6;
                        const tightening = this.trapRadius > minRadius;

                        if (tightening) {
                            this.trapRadius = Math.max(minRadius, this.trapRadius - 0.85);
                        }

                        // ============================================================
                        // COIL BAILOUT (FIXED)
                        // ============================================================
                        if (tightening) {
                            const BASE_BAIL_MULT = 2.3;
                            const SIZE_CAUTION_FACTOR = this.score / 320;
                            const MIN_BAIL_DISTANCE = 28;
                            const bailDistance = Math.max(MIN_BAIL_DISTANCE, this.width * (BASE_BAIL_MULT + SIZE_CAUTION_FACTOR));

                            for (let other of allSnakes) {
                                if (other === this || other === targetSnake || other.dead || Date.now() < other.ghostUntil) continue;
                                
                                for (let i = 0; i < other.tail.length; i += 3) {
                                    const seg = other.tail[i];
                                    if (!seg) continue;
                                    const dx = this.x - seg.x;
                                    const dy = this.y - seg.y;
                                    const distSq = dx * dx + dy * dy;
                                    
                                    if (distSq < bailDistance * bailDistance) {
                                        this.isDashing = false;

                                        const avoidAngle = Math.atan2(dy, dx);
                                        let diff = avoidAngle - this.angle;
                                        while (diff < -Math.PI) diff += Math.PI * 2;
                                        while (diff > Math.PI) diff -= Math.PI * 2;

                                        this.angle += diff * 1.0;
                                        
                                        const criticalDist = (this.width + other.width + 25)**2;
                                        if (distSq < criticalDist) {
                                            this.isTrapping = false;
                                            this.trapRadius = null;
                                            return;
                                        }
                                        return;
                                    }
                                }
                            }
                        }

                        if (this.score > 500) {
                            this.isDashing = true; 
                        }

                        const targetAngle = Math.atan2(this.y - targetSnake.y, this.x - targetSnake.x);
                        const wrapAngle = targetAngle + 0.95; 

                        targetX = targetSnake.x + Math.cos(wrapAngle) * this.trapRadius;
                        targetY = targetSnake.y + Math.sin(wrapAngle) * this.trapRadius;

                        if (distToTarget < this.trapRadius + 100) {
                            this.huntStartTime = Date.now(); 
                        }
                    }
                }
            }
        } else {
            this.huntStartTime = 0;
            this.hunterSpeedBoost = 1.0;
            this.stopChasing();
        }

        if (targetX === null) {
            this.isTrapping = false;
            this.isDashing = false;
            let bestFood = null, bestFoodDist = 800;
            for (let f of foods) {
                const dSq = (this.x - f.x)**2 + (this.y - f.y)**2;
                if (dSq < (bestFoodDist)**2) {
                    bestFoodDist = Math.sqrt(dSq);
                    bestFood = f;
                }
            }
            if (bestFood) { targetX = bestFood.x; targetY = bestFood.y; }
        }

        if (targetX !== null) {
            const targetAngle = Math.atan2(targetY - this.y, targetX - this.x);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * ((this.isHunter || this.isCivilWarAI) ? 0.35 : 0.15);
        } else {
            this.angle += (Math.random() - 0.5) * 0.1;
        }
    }
}



        stopChasing() {
        this.isTrapping = false;
        this.coilTarget = null;
        if (this.currentlyChasing === p1) targetTracker.p1 = 0;
        if (this.currentlyChasing === p2) targetTracker.p2 = 0;
        this.currentlyChasing = null;
    }

        die() {
        if (this.dead) return; 
        this.dead = true;
        
        // Track player deaths
        if (!this.isAI) {
            gameStats.totalDeaths++;
            saveStats();
        }
        
        this.stopChasing();
                // Dropped food from body - NOW WITH SPAWN TIME
        this.tail.forEach((seg, i) => {
            if (i % 5 === 0) {
                foods.push({
                    x: seg.x,
                    y: seg.y,
                    color: this.color,
                    isTemp: true, // This marks it as food from a dead snake
                    growthMult: 4.0,
                    radius: 9,
                    spawnTime: Date.now() // This records the exact millisecond it was created
                });
            }
        });
        if (this.id === 1) document.getElementById('p1-over').style.display = 'block';
        if (this.id === 2 && gameMode === 2) document.getElementById('p2-over').style.display = 'block';
        if (this.isAI) { setTimeout(() => { if (!gameActive) return; const p = getRandomPos(); this.reset(p.x, p.y); }, 2500); }
    }
}
function pauseGame(playerId) {
    if (!gameActive || gamePaused) return;

    gamePaused = true;
    pauseOwner = playerId;

    cancelAnimationFrame(animationId);

    // Show P1's pause menu
    document.getElementById('p1-pause').style.display = 'block';

    // Show P2's pause menu only if we are in multiplayer
    if (gameMode === 2) {
        document.getElementById('p2-pause').style.display = 'block';
    }
}

function resumeGame() {
    if (!gamePaused) return;

    gamePaused = false;
    pauseOwner = null;

    // Hide both potential pause menus
    document.getElementById('p1-pause').style.display = 'none';
    document.getElementById('p2-pause').style.display = 'none';

    loop();
}
function goToMenu() { 
    gamePaused = false;
    pauseOwner = null;
    document.getElementById('p1-pause').style.display = 'none';
    document.getElementById('p2-pause').style.display = 'none';
gameActive = false; cancelAnimationFrame(animationId); document.getElementById('game-wrapper').style.display = 'none'; document.getElementById('powerup-screen').style.display = 'none'; document.getElementById('menu').style.display = 'flex'; document.getElementById('p1-over').style.display = 'none'; document.getElementById('p2-over').style.display = 'none'; allSnakes = []; foods = []; dashParticles = []; empPulses = []; venomProjectiles = []; greenWalls = []; targetTracker = {p1:0, p2:0}; }
function restartGame(playerId) { const p = getRandomPos(); if (playerId === 1) { p1.reset(p.x, p.y); document.getElementById('p1-over').style.display = 'none'; } else { p2.reset(p.x, p.y); document.getElementById('p2-over').style.display = 'none'; } }
function init() {
    canvases.forEach(c => { c.width = window.innerWidth; c.height = (gameMode === 1 ? window.innerHeight : window.innerHeight / 2); });
        p1 = new Snake(1, 400, 400, p1Color, (gameMode === 1) ? "YOU" : "LUCY");
    p2 = new Snake(2, 2600, 2600, (gameMode === 2 ? p2Color : "#ff00de"), "ISAAC");
    allSnakes = [p1, p2];

    // Create standard AI snakes
    for(let i=0; i<CONFIG.AI_COUNT; i++) { 
        const pos = getRandomPos(); 
        allSnakes.push(new Snake(i+3, pos.x, pos.y, "#ffffff", AI_NAMES[i % AI_NAMES.length], true)); 
    }

    // --- START: Initial AI Score Boost ---
    // Targeted AI snakes start at index 2 (the first AI created)
    if (allSnakes.length > 7) {
        // 1 AI starts at 500+ Score (Length 280)
        allSnakes[2].length = 280;

        // 2 AI snakes start at 250+ Score (Length 155)
        allSnakes[3].length = 155;
        allSnakes[4].length = 155;

        // 2 AI snakes start at 100+ Score (Length 80)
        allSnakes[5].length = 80;
        allSnakes[6].length = 80;
    }
    // --- END: Initial AI Score Boost ---

    for(let i=0; i<CONFIG.foodCount; i++) { 
        const pos = getRandomPos(); 
        foods.push({ x: pos.x, y: pos.y, color: `hsl(${Math.random()*360},100%,70%)`, isTemp: false, growthMult: 1.0, radius: 4 }); 
    }
}

function updateVenomPhysics() {
    for(let i = venomProjectiles.length - 1; i >= 0; i--) {
        const v = venomProjectiles[i];
        v.x += Math.cos(v.angle) * v.speed; v.y += Math.sin(v.angle) * v.speed;
        let hit = false;
        for (let s of allSnakes) {
            if (s.dead || s === v.owner || Date.now() < s.ghostUntil) continue;
            for (let j = 0; j < s.tail.length - 5; j++) {
                const seg = s.tail[j];
                const dSq = (v.x - seg.x)**2 + (v.y - seg.y)**2;
                if (dSq < (v.radius + seg.w/2)**2) {
                    const severed = s.tail.splice(0, j + 1);
                    s.length = s.tail.length;
                    if (severed.length > 0) greenWalls.push({ segments: severed, expiry: Date.now() + 15000, opacity: 1.0 });
                    venomProjectiles.splice(i, 1); hit = true; break;
                }
            }
            if(hit) break;
        }
        if (!hit && (v.x < 0 || v.x > WORLD.width || v.y < 0 || v.y > WORLD.height)) venomProjectiles.splice(i, 1);
    }
}

function render(ctx, cameraSnake) {
    ctx.save(); ctx.translate(ctx.canvas.width/2 - cameraSnake.x, ctx.canvas.height/2 - cameraSnake.y);
    
    // === NIGHTMARE FOG (RENDERED FIRST) ===
    const nightmareSettings = CONFIG.difficulty.nightmare;
    const isNightmare = p1Difficulty === 'nightmare' && nightmareSettings.fogEnabled;
    
    if (isNightmare && !cameraSnake.isAI) {
        // Save current transform
        ctx.save();
        // Reset to screen coordinates
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        // Create radial gradient for fog
        const centerX = ctx.canvas.width / 2;
        const centerY = ctx.canvas.height / 2;
        const maxDim = Math.max(ctx.canvas.width, ctx.canvas.height);
        
        const fogGrad = ctx.createRadialGradient(
            centerX, centerY, nightmareSettings.fogVisibleRadius,
            centerX, centerY, maxDim
        );
        fogGrad.addColorStop(0, `rgba(0, 0, 0, 0)`);
        fogGrad.addColorStop(0.3, `rgba(0, 0, 0, ${nightmareSettings.fogOpacity * 0.5})`);
        fogGrad.addColorStop(1, `rgba(0, 0, 0, ${nightmareSettings.fogOpacity})`);
        
        ctx.fillStyle = fogGrad;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.restore();
        
        // Translate back for world rendering
        ctx.translate(ctx.canvas.width/2 - cameraSnake.x, ctx.canvas.height/2 - cameraSnake.y);
    }
    
                // --- GRAVITY WELL VISUAL WITH SMOOTH FADE ---
    const gravityTimeLeft = cameraSnake.gravityActiveUntil - Date.now();
    const gravityDuration = CONFIG.gravityActiveDuration;
    const gravityElapsed = gravityDuration - gravityTimeLeft;

    if (gravityTimeLeft > 0) {
        ctx.save();
        
        // Calculate Fade: 1 second (1000ms) for in and out
        let fadeAlpha = 1.0;
        if (gravityElapsed < 1000) {
            fadeAlpha = gravityElapsed / 1000; // Fade In
        } else if (gravityTimeLeft < 1000) {
            fadeAlpha = gravityTimeLeft / 1000; // Fade Out
        }

        const time = Date.now() * 0.008; 
        const swirlRadius = Math.max(ctx.canvas.width, ctx.canvas.height) * 0.25;
        
        ctx.translate(cameraSnake.x, cameraSnake.y);
        ctx.rotate(time); 
        
        const grad = ctx.createConicGradient(0, 0, 0);
        grad.addColorStop(0, "rgba(40, 40, 40, 0)");   
        grad.addColorStop(0.2, "rgba(100, 100, 100, 0.6)"); 
        grad.addColorStop(0.5, "rgba(20, 20, 20, 0.8)");    
        grad.addColorStop(0.8, "rgba(150, 150, 150, 0.6)"); 
        grad.addColorStop(1, "rgba(40, 40, 40, 0)");   
        
        ctx.fillStyle = grad;
        // Multiply your base opacity (0.7) by the fade factor
        ctx.globalAlpha = 0.7 * fadeAlpha; 
        
        ctx.beginPath();
        ctx.arc(0, 0, swirlRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
        // --- FIXED: GRID AND BACKGROUND EFFECTS ---
    ctx.strokeStyle = "#151515"; ctx.lineWidth = 2;
    for(let i=0; i<=WORLD.width; i+=250) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD.height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD.width, i); ctx.stroke(); }
    const gridPulse = Math.abs(Math.sin(Date.now() / 400)) * 6; ctx.strokeStyle = `rgba(255, 0, 0, ${0.4 + (gridPulse/15)})`; ctx.lineWidth = 15 + gridPulse; ctx.strokeRect(0, 0, WORLD.width, WORLD.height);
    
    empPulses.forEach((p, i) => {
        ctx.save(); ctx.beginPath(); ctx.strokeStyle = p.color || "#00f2ff"; ctx.globalAlpha = p.alpha; ctx.lineWidth = 4; ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
        p.radius += 25; p.alpha -= 0.025; if (p.alpha <= 0) empPulses.splice(i, 1);
    });

    venomProjectiles.forEach(v => {
        ctx.fillStyle = "#2bff00"; ctx.shadowBlur = 10; ctx.shadowColor = "#2bff00";
        ctx.beginPath(); ctx.arc(v.x, v.y, v.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
    });

    for(let wIdx = greenWalls.length - 1; wIdx >= 0; wIdx--) {
        const wall = greenWalls[wIdx];
        const timeLeft = wall.expiry - Date.now();
        if (timeLeft <= 0) { greenWalls.splice(wIdx, 1); continue; }
        if (timeLeft < 2000) wall.opacity = timeLeft / 2000;
        ctx.save(); ctx.globalAlpha = wall.opacity; ctx.strokeStyle = "#2bff00"; ctx.shadowBlur = 15; ctx.shadowColor = "#2bff00"; ctx.lineCap = "round";
        ctx.beginPath();
        if(wall.segments.length > 0) ctx.moveTo(wall.segments[0].x, wall.segments[0].y);
        wall.segments.forEach((seg, sIdx) => {
            if (sIdx > 0) ctx.lineTo(seg.x, seg.y);
            allSnakes.forEach(snake => { 
                if (snake.dead || Date.now() < snake.ghostUntil) return; 
                const dSq = (snake.x - seg.x)**2 + (snake.y - seg.y)**2; 
                if (dSq < (snake.width/2 + seg.w/2)**2) snake.die(); 
            });
        });
        ctx.lineWidth = wall.segments[0]?.w || 10; ctx.stroke(); ctx.restore();
    }

    // --- FIXED AURA & BODY BOOST RENDERING ---
        allSnakes.forEach(s => { 
        if (s.dead) return;
        if (Date.now() < s.ghostUntil && s !== cameraSnake) return;

        // Calculate nightmare fog dimming for AI snakes
        const nightmareSettings = CONFIG.difficulty.nightmare;
        const isNightmare = p1Difficulty === 'nightmare' && nightmareSettings.fogEnabled;
        let nightmareDim = 1.0;
        
        if (isNightmare && s.isAI) {
            const distToCamera = Math.sqrt(
                (s.x - cameraSnake.x) ** 2 + (s.y - cameraSnake.y) ** 2
            );
            if (distToCamera > nightmareSettings.fogVisibleRadius) {
                nightmareDim = nightmareSettings.fogAIOpacity;
            }
        }

        let auraColor = null;
const isBoosting = Date.now() < s.boostActiveUntil;
const isKillshotActive = Date.now() < s.killshotActiveUntil;

        // 1. Set IDLE aura color
        if (s.isAI) {
            auraColor = "rgba(255, 0, 0, 0.4)";
        } else {
            const power = (s.id === 1) ? p1Selected : p2Selected;
            if (power === 1) auraColor = "rgba(0, 242, 255, 0.4)"; 
            else if (power === 2) auraColor = "rgba(43, 255, 0, 0.4)"; 
            else if (power === 3) auraColor = "rgba(255, 255, 255, 0.4)"; 
            else if (power === 4) auraColor = "rgba(0, 100, 255, 0.4)"; 
            else if (power === 5) auraColor = "rgba(188, 19, 254, 0.4)"; 
            else if (power === 6) auraColor = "rgba(255, 0, 0, 0.4)";
        }

        // 2. Render ACTIVE Pulsating Full-Body Aura
if (isBoosting || isKillshotActive) {
    const color = isBoosting ? "#bc13fe" : "#ff0000";
    
    ctx.save();
    
    // KILLSHOT: Rapid flash when < 2 seconds remaining
    let pulse;
    if (isKillshotActive) {
        const timeLeft = s.killshotActiveUntil - Date.now();
        if (timeLeft < 2000) {
            // Super rapid flash (10x faster)
            pulse = 0.6 + Math.sin(Date.now() / 50) * 0.4;
        } else {
            pulse = 0.6 + Math.sin(Date.now() / 100) * 0.3;
        }
    } else {
        pulse = 0.6 + Math.sin(Date.now() / 100) * 0.3;
    }
    
    ctx.globalAlpha = pulse;
            // Match head aura size (width * 3.0)
const auraWidth = s.width * 3.0;
ctx.shadowBlur = 60; // Softer glow
ctx.shadowColor = color;
ctx.strokeStyle = color;
ctx.lineWidth = auraWidth; // Same size as head aura
ctx.lineCap = "round"; ctx.lineJoin = "round";

ctx.beginPath();
if (s.tail.length > 0) {
    ctx.moveTo(s.tail[0].x, s.tail[0].y);
    s.tail.forEach(t => ctx.lineTo(t.x, t.y));
}
ctx.stroke();
ctx.restore();
            
            // For Boost: Draw LOTS of sparkles
if (isBoosting) {
    ctx.save();
    const trailPulse = 0.6 + Math.sin(Date.now() / 80) * 0.3;
    ctx.globalAlpha = trailPulse * 0.8;
    ctx.shadowBlur = 25; ctx.shadowColor = "#bc13fe";
    
    // Main trail sparkles (doubled)
    for (let i = 0; i < 12; i++) { // Was 5, now 12
        const offset = i * 12; // Closer together
        const trailX = s.x - Math.cos(s.angle) * offset;
        const trailY = s.y - Math.sin(s.angle) * offset;
        const sparkleSize = 6 - i * 0.3; // Bigger (was 4)
        ctx.fillStyle = "#bc13fe"; 
        ctx.beginPath(); 
        ctx.arc(trailX, trailY, sparkleSize, 0, Math.PI * 2); 
        ctx.fill();
    }
    
    // Side sparkles for thickness
    for (let i = 0; i < 8; i++) {
        const offset = i * 15;
        const perpAngle = s.angle + Math.PI / 2;
        const sideOffset = (Math.random() - 0.5) * s.width * 1.5;
        const trailX = s.x - Math.cos(s.angle) * offset + Math.cos(perpAngle) * sideOffset;
        const trailY = s.y - Math.sin(s.angle) * offset + Math.sin(perpAngle) * sideOffset;
        ctx.fillStyle = "#bc13fe";
        ctx.beginPath();
        ctx.arc(trailX, trailY, 5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
}
        }

        // 3. ALWAYS Render Head Aura if color exists (Moved out of 'else')
        if (auraColor) {
            const auraSize = s.width * 4.5 + (Math.sin(Date.now() / 200) * 12); 
            const grad = ctx.createRadialGradient(s.x, s.y, s.width/2, s.x, s.y, auraSize); 
            grad.addColorStop(0, auraColor); 
            grad.addColorStop(1, "rgba(0, 0, 0, 0)"); 
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(s.x, s.y, auraSize, 0, Math.PI * 2); ctx.fill(); 
        }
    });

        dashParticles.forEach((p, i) => { 
        ctx.globalAlpha = p.life * 0.8; // slightly brighter
        ctx.fillStyle = p.color; 
        ctx.beginPath(); 
        if (p.shape === 'rect') {
            ctx.fillRect(p.x - p.w/2, p.y - p.w/2, p.w, p.w);
        } else {
            ctx.arc(p.x, p.y, p.w/2, 0, Math.PI*2); 
            ctx.fill(); 
        }
        p.life -= 0.03; // Fade slightly faster
        if (p.life <= 0) dashParticles.splice(i, 1); 
    });
        // Food Logic with 10-second lifetime and 1-second fade
    // We use a "for" loop backwards so we can safely remove food from the list as we go
    for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        let currentOpacity = 1.0;

        // Only apply timing logic to food dropped by dead snakes (isTemp)
        if (f.isTemp) {
            const ageInMilliseconds = Date.now() - f.spawnTime;
            
            // If it has been on screen longer than 11 seconds (10s wait + 1s fade), delete it
            if (ageInMilliseconds > 11000) {
                foods.splice(i, 1);
                continue; // Skip drawing this one and move to the next
            } 
            // If it is between 10 and 11 seconds old, calculate the fade
            else if (ageInMilliseconds > 10000) {
                // This math turns 10.0-11.0 seconds into an opacity of 1.0 to 0.0
                currentOpacity = 1.0 - ((ageInMilliseconds - 10000) / 1000);
            }
        }

        ctx.globalAlpha = currentOpacity;
        ctx.fillStyle = f.color;

        if (f.growthMult > 1) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = f.color;
            const fPulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.radius * fPulse, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;
    }
    // Reset alpha to 100% so the snakes don't look transparent too!
    ctx.globalAlpha = 1.0;
    
        allSnakes.forEach(s => { 
        if (s.dead || (s.id === 2 && gameMode === 1)) return; 
        if (Date.now() < s.ghostUntil && s !== cameraSnake) return;
        const ghost = Date.now() < s.ghostUntil; const leader = s.id === leaderId; const isSlowed = Date.now() < s.slowedUntil;
        
        // Calculate nightmare fog dimming for AI snakes (NEEDED HERE TOO)
        let nightmareDim = 1.0;
        if (isNightmare && s.isAI) {
            const distToCamera = Math.sqrt(
                (s.x - cameraSnake.x) ** 2 + (s.y - cameraSnake.y) ** 2
            );
            if (distToCamera > nightmareSettings.fogVisibleRadius) {
                nightmareDim = nightmareSettings.fogAIOpacity;
            }
        }
        
        const gTimeLeft = s.gravityActiveUntil - Date.now();
        const gElapsed = CONFIG.gravityActiveDuration - gTimeLeft;
        let gFade = 0;
        if (gTimeLeft > 0) {
            gFade = (gElapsed < 1000) ? gElapsed / 1000 : (gTimeLeft < 1000 ? gTimeLeft / 1000 : 1);
        }

        ctx.save();
        const baseAlpha = ghost ? 0.35 + Math.sin(Date.now()/100)*0.15 : 1.0;
        ctx.globalAlpha = baseAlpha * nightmareDim;
        ctx.globalAlpha = baseAlpha * nightmareDim;
        
        // Use gFade to transition the shadowBlur from normal to 100
        const baseBlur = (leader ? 25 : (s.isAI ? 0 : 15));
        ctx.shadowBlur = baseBlur + ( (100 - baseBlur) * gFade );
        
                        // 1. Draw Normal Snake Base
        // FIX: Force leader color to always be gold in the base render
        const effectiveColor = (leader && s.score > 0) ? "gold" : s.color;
        
        ctx.shadowColor = (gFade > 0.5) ? effectiveColor : effectiveColor;
        ctx.strokeStyle = (gFade > 0.5) ? effectiveColor : (isSlowed ? "#444" : effectiveColor);
        
        ctx.lineWidth = s.width; ctx.lineCap = "round"; ctx.lineJoin = "round";  
        ctx.beginPath(); 
        if(s.tail.length > 0) { ctx.moveTo(s.tail[0].x, s.tail[0].y); s.tail.forEach(t => ctx.lineTo(t.x, t.y)); } 
        ctx.stroke();

        // 2. Draw Gold Overlay (Fading)
        if (s.leaderAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = ctx.globalAlpha * s.leaderAlpha; // Combine with ghost alpha
            ctx.shadowColor = "gold";
            ctx.strokeStyle = "gold";
            ctx.shadowBlur = 25; // Force leader blur
            ctx.stroke(); // Stroke the same path again
            ctx.restore();
        }

        // 3. Crown
        if (leader && s.score > 0) { 
            ctx.translate(s.x, s.y); 
            ctx.rotate(s.angle + Math.PI/2); 
            ctx.fillStyle = "gold"; 
            ctx.textAlign = "center"; 
            ctx.font = "bold 26px Arial"; 
            ctx.fillText("\uD83D\uDC51", 0, -22); 
        } 
        ctx.restore(); 
    });
    ctx.restore();
    const size = 90, margin = 20; const mx = (cameraSnake.id === 1 && gameMode === 2) ? ctx.canvas.width - size - margin : margin; const my = (cameraSnake.id === 1 && gameMode === 2) ? margin : ctx.canvas.height - size - margin; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha = 0.6; ctx.fillStyle = "#111"; ctx.fillRect(mx, my, size, size); ctx.strokeStyle = "#ff0000"; ctx.lineWidth = 2; ctx.strokeRect(mx, my, size, size); allSnakes.forEach(s => { if(!s.dead && !(s.id === 2 && gameMode === 1) && Date.now() >= s.ghostUntil) { 
        ctx.fillStyle = (s.id === leaderId && s.score > 0) ? "gold" : s.color; 
        ctx.beginPath(); ctx.arc(mx+(s.x/WORLD.width)*size, my+(s.y/WORLD.height)*size, 2.5,0,Math.PI*2); ctx.fill(); 
    }}); ctx.restore();
}

function handlePointerDown(e) { 
    if (e.target.tagName === 'BUTTON' || e.target.closest('.game-over') || !gameActive) return; 
    const isTop = gameMode === 1 || e.clientY < window.innerHeight / 2; 
    const p = isTop ? p1 : p2; 
    if (p.dead) return; 
    const rect = canvases[isTop ? 0 : 1].getBoundingClientRect(); 
    const x = e.clientX - rect.left; 
    const y = e.clientY - rect.top; 
    if (!p.joystick.active) { 
        p.joystick = { active: true, id: e.pointerId, startX: x, startY: y, currX: x, currY: y }; 
    } else if (!p.isDashing) { 
        p.isDashing = true; 
        p.dashId = e.pointerId; 
    } 
}
function handlePointerMove(e) { if (!gameActive) return; [p1, p2].forEach(p => { if (p.joystick.active && p.joystick.id === e.pointerId) { const isTop = (p.id === 1); const rect = canvases[isTop ? 0 : 1].getBoundingClientRect(); p.joystick.currX = e.clientX - rect.left; p.joystick.currY = e.clientY - rect.top; } }); }
function handlePointerUp(e) { [p1, p2].forEach(p => { if (p.joystick.id === e.pointerId) p.joystick.active = false; if (p.dashId === e.pointerId) { p.isDashing = false; p.dashId = null; } }); }

window.addEventListener('pointerdown', handlePointerDown);
window.addEventListener('pointermove', handlePointerMove);
window.addEventListener('pointerup', handlePointerUp);
window.addEventListener('pointercancel', handlePointerUp);

function loop() {
    if (!gameActive || gamePaused) return;
    updateVenomPhysics();
    
    let topScore = -1; 
    allSnakes.forEach(s => { 
        if (s.id === 2 && gameMode === 1) return; 
        s.update(); 
        
        // Track highest score
        if (!s.isAI && s.score > gameStats.highestScore) {
            gameStats.highestScore = s.score;
            saveStats();
        }
        
        if (!s.dead && s.score > topScore) { 
            topScore = s.score; 
            leaderId = s.id; 
        } 
    });
    
    // Track leader time
    const isPlayerLeader = (leaderId === p1.id || (gameMode === 2 && leaderId === p2.id));
    if (isPlayerLeader && !wasLeaderLastFrame) {
        currentLeaderStartTime = Date.now();
        wasLeaderLastFrame = true;
    } else if (!isPlayerLeader && wasLeaderLastFrame) {
        const leaderDuration = Date.now() - currentLeaderStartTime;
        if (leaderDuration > gameStats.longestLeaderTime) {
            gameStats.longestLeaderTime = leaderDuration;
            saveStats();
        }
        wasLeaderLastFrame = false;
    }
    
    const relevantSnakes = allSnakes.filter(s => !(s.id === 2 && gameMode === 1));
const sortedSnakes = [...relevantSnakes].sort((a,b) => b.score - a.score);

// Function to generate leaderboard HTML for a specific player's view
function generateLeaderboardHTML(viewerSnake) {
    const viewerRank = sortedSnakes.findIndex(s => s.id === viewerSnake.id) + 1;
    const inTop5 = viewerRank <= 5 && viewerRank > 0;
    
    let html = "";
    const displaySnakes = inTop5 ? sortedSnakes.slice(0, 5) : [...sortedSnakes.slice(0, 4), viewerSnake];
    
    displaySnakes.forEach((s, idx) => {
        const actualRank = inTop5 ? (idx + 1) : (idx < 4 ? (idx + 1) : viewerRank);
        const isLeader = (s.id === leaderId && s.score > 0);
        const isViewer = (s.id === viewerSnake.id);
        
        html += `<div class="lb-item ${isLeader ? 'lb-leader' : ''}" style="color:${s.isAI && !isLeader ? '#fff' : s.color}">
            <span class="lb-name">${actualRank}.${s.name.substring(0,7)}</span>
            <span class="lb-score">${s.score}</span>
        </div>`;
    });
    
    return html;
}

lbLists[0].innerHTML = generateLeaderboardHTML(p1);
if (gameMode === 2) {
    lbLists[1].innerHTML = generateLeaderboardHTML(p2);
}
    canvases.forEach((c, i) => { if (i === 1 && gameMode === 1) return; const ctx = c.getContext('2d'); ctx.fillStyle = "#000"; ctx.fillRect(0, 0, c.width, c.height); render(ctx, i === 0 ? p1 : p2); uis[i].innerText = `${(i===0?p1:p2).name}: ${(i===0?p1:p2).score}`; });
    animationId = requestAnimationFrame(loop);
}

window.addEventListener('resize', () => { 
    canvases[0].width = window.innerWidth; canvases[0].height = gameMode === 1 ? window.innerHeight : window.innerHeight / 2; 
    canvases[1].width = window.innerWidth; canvases[1].height = window.innerHeight / 2; 
});
</script>
</body>
</html>
